/*
* audio_ut_module.c- Sigmastar
*
* Copyright (c) [2019~2020] SigmaStar Technology.
*
*
* This software is licensed under the terms of the GNU General Public
* License version 2, as published by the Free Software Foundation, and
* may be copied, distributed, and modified under those terms.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License version 2 for more details.
*
*/

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/slab.h>
#include <linux/platform_device.h>
#include <linux/cdev.h>
#include <sound/core.h>
#include <sound/pcm.h>

#include <linux/of.h>
#include <linux/of_irq.h>
#include <linux/delay.h>
#include <linux/kthread.h>

#include "cam_os_wrapper.h"
#include "cam_sysfs.h"
#include "mhal_audio.h"
#include "ms_msys.h"

#include "drv_audio_io.h"
#include "audio_test_ioctl.h"
#include "audio_test_type.h"

#define TEST_AO_EMPTY           ( 0 )
#define TEST_AI_FULL            ( 0 )
#define TEST_AO_SPECIAL_SINE    ( 0 ) // For TEST_AO_EMPTY
#define TEST_DPGA_GAIN_FADING   ( 0 )
#define TEST_ADC_GAIN           ( 0 ) // Mic: 0~21 , Line-in: 0~7
#define TEST_AO_HOT_STOP        ( 0 )
#if TEST_DPGA_GAIN_FADING
#define TEST_FADING_AO  ( 0 )
#define TEST_FADING_AI  ( 0 )
#endif

#define AUDIO_IN_DEV    (6)
#define AUDIO_OUT_DEV   (6)
#define AUDIO_DEV (AUDIO_IN_DEV+AUDIO_OUT_DEV)

#define MIU_OFFSET 0x20000000

struct file **fw;
struct file *ao_file;
mm_segment_t fs;

#if 1
u8 tone_48k[] =
{
    0x00, 0x00, 0x00, 0x00, 0x5F, 0x08, 0x60, 0x08, 0x9B, 0x10, 0x9A, 0x10, 0x8D, 0x18, 0x8C, 0x18,
    0x13, 0x20, 0x13, 0x20, 0x0D, 0x27, 0x0D, 0x27, 0x5C, 0x2D, 0x5D, 0x2D, 0xE5, 0x32, 0xE4, 0x32,
    0x8F, 0x37, 0x8E, 0x37, 0x44, 0x3B, 0x44, 0x3B, 0xF7, 0x3D, 0xF7, 0x3D, 0x9A, 0x3F, 0x99, 0x3F,
    0x27, 0x40, 0x26, 0x40, 0x9A, 0x3F, 0x99, 0x3F, 0xF6, 0x3D, 0xF7, 0x3D, 0x45, 0x3B, 0x44, 0x3B,
    0x8F, 0x37, 0x8E, 0x37, 0xE5, 0x32, 0xE5, 0x32, 0x5C, 0x2D, 0x5D, 0x2D, 0x0E, 0x27, 0x0D, 0x27,
    0x13, 0x20, 0x13, 0x20, 0x8C, 0x18, 0x8D, 0x18, 0x9A, 0x10, 0x9B, 0x10, 0x60, 0x08, 0x60, 0x08,
    0x00, 0x00, 0x00, 0x00, 0xA1, 0xF7, 0xA1, 0xF7, 0x66, 0xEF, 0x65, 0xEF, 0x73, 0xE7, 0x73, 0xE7,
    0xED, 0xDF, 0xEC, 0xDF, 0xF3, 0xD8, 0xF4, 0xD8, 0xA3, 0xD2, 0xA3, 0xD2, 0x1B, 0xCD, 0x1B, 0xCD,
    0x71, 0xC8, 0x72, 0xC8, 0xBC, 0xC4, 0xBC, 0xC4, 0x09, 0xC2, 0x09, 0xC2, 0x66, 0xC0, 0x66, 0xC0,
    0xD9, 0xBF, 0xDA, 0xBF, 0x66, 0xC0, 0x66, 0xC0, 0x09, 0xC2, 0x09, 0xC2, 0xBB, 0xC4, 0xBC, 0xC4,
    0x72, 0xC8, 0x71, 0xC8, 0x1B, 0xCD, 0x1C, 0xCD, 0xA4, 0xD2, 0xA3, 0xD2, 0xF2, 0xD8, 0xF3, 0xD8,
    0xEC, 0xDF, 0xED, 0xDF, 0x73, 0xE7, 0x74, 0xE7, 0x66, 0xEF, 0x66, 0xEF, 0xA1, 0xF7, 0xA1, 0xF7,
    0x00, 0x00, 0x00, 0x00, 0x5F, 0x08, 0x60, 0x08, 0x9B, 0x10, 0x9A, 0x10, 0x8D, 0x18, 0x8C, 0x18,
    0x13, 0x20, 0x13, 0x20, 0x0D, 0x27, 0x0D, 0x27, 0x5C, 0x2D, 0x5D, 0x2D, 0xE5, 0x32, 0xE4, 0x32,
    0x8F, 0x37, 0x8E, 0x37, 0x44, 0x3B, 0x44, 0x3B, 0xF7, 0x3D, 0xF7, 0x3D, 0x9A, 0x3F, 0x99, 0x3F,
    0x27, 0x40, 0x26, 0x40, 0x9A, 0x3F, 0x99, 0x3F, 0xF6, 0x3D, 0xF7, 0x3D, 0x45, 0x3B, 0x44, 0x3B,
    0x8F, 0x37, 0x8E, 0x37, 0xE5, 0x32, 0xE5, 0x32, 0x5C, 0x2D, 0x5D, 0x2D, 0x0E, 0x27, 0x0D, 0x27,
    0x13, 0x20, 0x13, 0x20, 0x8C, 0x18, 0x8D, 0x18, 0x9A, 0x10, 0x9B, 0x10, 0x60, 0x08, 0x60, 0x08,
    0x00, 0x00, 0x00, 0x00, 0xA1, 0xF7, 0xA1, 0xF7, 0x66, 0xEF, 0x65, 0xEF, 0x73, 0xE7, 0x73, 0xE7,
    0xED, 0xDF, 0xEC, 0xDF, 0xF3, 0xD8, 0xF4, 0xD8, 0xA3, 0xD2, 0xA3, 0xD2, 0x1B, 0xCD, 0x1B, 0xCD,
    0x71, 0xC8, 0x72, 0xC8, 0xBC, 0xC4, 0xBC, 0xC4, 0x09, 0xC2, 0x09, 0xC2, 0x66, 0xC0, 0x66, 0xC0,
    0xD9, 0xBF, 0xDA, 0xBF, 0x66, 0xC0, 0x66, 0xC0, 0x09, 0xC2, 0x09, 0xC2, 0xBB, 0xC4, 0xBC, 0xC4,
    0x72, 0xC8, 0x71, 0xC8, 0x1B, 0xCD, 0x1C, 0xCD, 0xA4, 0xD2, 0xA3, 0xD2, 0xF2, 0xD8, 0xF3, 0xD8,
    0xEC, 0xDF, 0xED, 0xDF, 0x73, 0xE7, 0x74, 0xE7, 0x66, 0xEF, 0x66, 0xEF, 0xA1, 0xF7, 0xA1, 0xF7,
    0x00, 0x00, 0x00, 0x00, 0x5F, 0x08, 0x60, 0x08, 0x9B, 0x10, 0x9A, 0x10, 0x8D, 0x18, 0x8C, 0x18,
    0x13, 0x20, 0x13, 0x20, 0x0D, 0x27, 0x0D, 0x27, 0x5C, 0x2D, 0x5D, 0x2D, 0xE5, 0x32, 0xE4, 0x32,
    0x8F, 0x37, 0x8E, 0x37, 0x44, 0x3B, 0x44, 0x3B, 0xF7, 0x3D, 0xF7, 0x3D, 0x9A, 0x3F, 0x99, 0x3F,
    0x27, 0x40, 0x26, 0x40, 0x9A, 0x3F, 0x99, 0x3F, 0xF6, 0x3D, 0xF7, 0x3D, 0x45, 0x3B, 0x44, 0x3B,
    0x8F, 0x37, 0x8E, 0x37, 0xE5, 0x32, 0xE5, 0x32, 0x5C, 0x2D, 0x5D, 0x2D, 0x0E, 0x27, 0x0D, 0x27,
    0x13, 0x20, 0x13, 0x20, 0x8C, 0x18, 0x8D, 0x18, 0x9A, 0x10, 0x9B, 0x10, 0x60, 0x08, 0x60, 0x08,
    0x00, 0x00, 0x00, 0x00, 0xA1, 0xF7, 0xA1, 0xF7, 0x66, 0xEF, 0x65, 0xEF, 0x73, 0xE7, 0x73, 0xE7,
    0xED, 0xDF, 0xEC, 0xDF, 0xF3, 0xD8, 0xF4, 0xD8, 0xA3, 0xD2, 0xA3, 0xD2, 0x1B, 0xCD, 0x1B, 0xCD,
    0x71, 0xC8, 0x72, 0xC8, 0xBC, 0xC4, 0xBC, 0xC4, 0x09, 0xC2, 0x09, 0xC2, 0x66, 0xC0, 0x66, 0xC0,
    0xD9, 0xBF, 0xDA, 0xBF, 0x66, 0xC0, 0x66, 0xC0, 0x09, 0xC2, 0x09, 0xC2, 0xBB, 0xC4, 0xBC, 0xC4,
    0x72, 0xC8, 0x71, 0xC8, 0x1B, 0xCD, 0x1C, 0xCD, 0xA4, 0xD2, 0xA3, 0xD2, 0xF2, 0xD8, 0xF3, 0xD8,
    0xEC, 0xDF, 0xED, 0xDF, 0x73, 0xE7, 0x74, 0xE7, 0x66, 0xEF, 0x66, 0xEF, 0xA1, 0xF7, 0xA1, 0xF7,
    0x00, 0x00, 0x00, 0x00, 0x5F, 0x08, 0x60, 0x08, 0x9B, 0x10, 0x9A, 0x10, 0x8D, 0x18, 0x8C, 0x18,
    0x13, 0x20, 0x13, 0x20, 0x0D, 0x27, 0x0D, 0x27, 0x5C, 0x2D, 0x5D, 0x2D, 0xE5, 0x32, 0xE4, 0x32,
    0x8F, 0x37, 0x8E, 0x37, 0x44, 0x3B, 0x44, 0x3B, 0xF7, 0x3D, 0xF7, 0x3D, 0x9A, 0x3F, 0x99, 0x3F,
    0x27, 0x40, 0x26, 0x40, 0x9A, 0x3F, 0x99, 0x3F, 0xF6, 0x3D, 0xF7, 0x3D, 0x45, 0x3B, 0x44, 0x3B,
    0x8F, 0x37, 0x8E, 0x37, 0xE5, 0x32, 0xE5, 0x32, 0x5C, 0x2D, 0x5D, 0x2D, 0x0E, 0x27, 0x0D, 0x27,
    0x13, 0x20, 0x13, 0x20, 0x8C, 0x18, 0x8D, 0x18, 0x9A, 0x10, 0x9B, 0x10, 0x60, 0x08, 0x60, 0x08,
    0x00, 0x00, 0x00, 0x00, 0xA1, 0xF7, 0xA1, 0xF7, 0x66, 0xEF, 0x65, 0xEF, 0x73, 0xE7, 0x73, 0xE7,
    0xED, 0xDF, 0xEC, 0xDF, 0xF3, 0xD8, 0xF4, 0xD8, 0xA3, 0xD2, 0xA3, 0xD2, 0x1B, 0xCD, 0x1B, 0xCD,
    0x71, 0xC8, 0x72, 0xC8, 0xBC, 0xC4, 0xBC, 0xC4, 0x09, 0xC2, 0x09, 0xC2, 0x66, 0xC0, 0x66, 0xC0,
    0xD9, 0xBF, 0xDA, 0xBF, 0x66, 0xC0, 0x66, 0xC0, 0x09, 0xC2, 0x09, 0xC2, 0xBB, 0xC4, 0xBC, 0xC4,
    0x72, 0xC8, 0x71, 0xC8, 0x1B, 0xCD, 0x1C, 0xCD, 0xA4, 0xD2, 0xA3, 0xD2, 0xF2, 0xD8, 0xF3, 0xD8,
    0xEC, 0xDF, 0xED, 0xDF, 0x73, 0xE7, 0x74, 0xE7, 0x66, 0xEF, 0x66, 0xEF, 0xA1, 0xF7, 0xA1, 0xF7,
    0x00, 0x00, 0x00, 0x00, 0x5F, 0x08, 0x60, 0x08, 0x9B, 0x10, 0x9A, 0x10, 0x8D, 0x18, 0x8C, 0x18,
    0x13, 0x20, 0x13, 0x20, 0x0D, 0x27, 0x0D, 0x27, 0x5C, 0x2D, 0x5D, 0x2D, 0xE5, 0x32, 0xE4, 0x32,
    0x8F, 0x37, 0x8E, 0x37, 0x44, 0x3B, 0x44, 0x3B, 0xF7, 0x3D, 0xF7, 0x3D, 0x9A, 0x3F, 0x99, 0x3F,
    0x27, 0x40, 0x26, 0x40, 0x9A, 0x3F, 0x99, 0x3F, 0xF6, 0x3D, 0xF7, 0x3D, 0x45, 0x3B, 0x44, 0x3B,
    0x8F, 0x37, 0x8E, 0x37, 0xE5, 0x32, 0xE5, 0x32, 0x5C, 0x2D, 0x5D, 0x2D, 0x0E, 0x27, 0x0D, 0x27,
    0x13, 0x20, 0x13, 0x20, 0x8C, 0x18, 0x8D, 0x18, 0x9A, 0x10, 0x9B, 0x10, 0x60, 0x08, 0x60, 0x08,
    0x00, 0x00, 0x00, 0x00, 0xA1, 0xF7, 0xA1, 0xF7, 0x66, 0xEF, 0x65, 0xEF, 0x73, 0xE7, 0x73, 0xE7,
    0xED, 0xDF, 0xEC, 0xDF, 0xF3, 0xD8, 0xF4, 0xD8, 0xA3, 0xD2, 0xA3, 0xD2, 0x1B, 0xCD, 0x1B, 0xCD,
    0x71, 0xC8, 0x72, 0xC8, 0xBC, 0xC4, 0xBC, 0xC4, 0x09, 0xC2, 0x09, 0xC2, 0x66, 0xC0, 0x66, 0xC0,
    0xD9, 0xBF, 0xDA, 0xBF, 0x66, 0xC0, 0x66, 0xC0, 0x09, 0xC2, 0x09, 0xC2, 0xBB, 0xC4, 0xBC, 0xC4,
    0x72, 0xC8, 0x71, 0xC8, 0x1B, 0xCD, 0x1C, 0xCD, 0xA4, 0xD2, 0xA3, 0xD2, 0xF2, 0xD8, 0xF3, 0xD8,
    0xEC, 0xDF, 0xED, 0xDF, 0x73, 0xE7, 0x74, 0xE7, 0x66, 0xEF, 0x66, 0xEF, 0xA1, 0xF7, 0xA1, 0xF7,
    0x00, 0x00, 0x00, 0x00, 0x5F, 0x08, 0x60, 0x08, 0x9B, 0x10, 0x9A, 0x10, 0x8D, 0x18, 0x8C, 0x18,
    0x13, 0x20, 0x13, 0x20, 0x0D, 0x27, 0x0D, 0x27, 0x5C, 0x2D, 0x5D, 0x2D, 0xE5, 0x32, 0xE4, 0x32,
    0x8F, 0x37, 0x8E, 0x37, 0x44, 0x3B, 0x44, 0x3B, 0xF7, 0x3D, 0xF7, 0x3D, 0x9A, 0x3F, 0x99, 0x3F,
    0x27, 0x40, 0x26, 0x40, 0x9A, 0x3F, 0x99, 0x3F, 0xF6, 0x3D, 0xF7, 0x3D, 0x45, 0x3B, 0x44, 0x3B,
    0x8F, 0x37, 0x8E, 0x37, 0xE5, 0x32, 0xE5, 0x32, 0x5C, 0x2D, 0x5D, 0x2D, 0x0E, 0x27, 0x0D, 0x27,
    0x13, 0x20, 0x13, 0x20, 0x8C, 0x18, 0x8D, 0x18, 0x9A, 0x10, 0x9B, 0x10, 0x60, 0x08, 0x60, 0x08,
    0x00, 0x00, 0x00, 0x00, 0xA1, 0xF7, 0xA1, 0xF7, 0x66, 0xEF, 0x65, 0xEF, 0x73, 0xE7, 0x73, 0xE7,
    0xED, 0xDF, 0xEC, 0xDF, 0xF3, 0xD8, 0xF4, 0xD8, 0xA3, 0xD2, 0xA3, 0xD2, 0x1B, 0xCD, 0x1B, 0xCD,
    0x71, 0xC8, 0x72, 0xC8, 0xBC, 0xC4, 0xBC, 0xC4, 0x09, 0xC2, 0x09, 0xC2, 0x66, 0xC0, 0x66, 0xC0,
    0xD9, 0xBF, 0xDA, 0xBF, 0x66, 0xC0, 0x66, 0xC0, 0x09, 0xC2, 0x09, 0xC2, 0xBB, 0xC4, 0xBC, 0xC4,
    0x72, 0xC8, 0x71, 0xC8, 0x1B, 0xCD, 0x1C, 0xCD, 0xA4, 0xD2, 0xA3, 0xD2, 0xF2, 0xD8, 0xF3, 0xD8,
    0xEC, 0xDF, 0xED, 0xDF, 0x73, 0xE7, 0x74, 0xE7, 0x66, 0xEF, 0x66, 0xEF, 0xA1, 0xF7, 0xA1, 0xF7,
    0x00, 0x00, 0x00, 0x00, 0x5F, 0x08, 0x60, 0x08, 0x9B, 0x10, 0x9A, 0x10, 0x8D, 0x18, 0x8C, 0x18,
    0x13, 0x20, 0x13, 0x20, 0x0D, 0x27, 0x0D, 0x27, 0x5C, 0x2D, 0x5D, 0x2D, 0xE5, 0x32, 0xE4, 0x32,
    0x8F, 0x37, 0x8E, 0x37, 0x44, 0x3B, 0x44, 0x3B, 0xF7, 0x3D, 0xF7, 0x3D, 0x9A, 0x3F, 0x99, 0x3F,
    0x27, 0x40, 0x26, 0x40, 0x9A, 0x3F, 0x99, 0x3F, 0xF6, 0x3D, 0xF7, 0x3D, 0x45, 0x3B, 0x44, 0x3B,
    0x8F, 0x37, 0x8E, 0x37, 0xE5, 0x32, 0xE5, 0x32, 0x5C, 0x2D, 0x5D, 0x2D, 0x0E, 0x27, 0x0D, 0x27,
    0x13, 0x20, 0x13, 0x20, 0x8C, 0x18, 0x8D, 0x18, 0x9A, 0x10, 0x9B, 0x10, 0x60, 0x08, 0x60, 0x08,
    0x00, 0x00, 0x00, 0x00, 0xA1, 0xF7, 0xA1, 0xF7, 0x66, 0xEF, 0x65, 0xEF, 0x73, 0xE7, 0x73, 0xE7,
    0xED, 0xDF, 0xEC, 0xDF, 0xF3, 0xD8, 0xF4, 0xD8, 0xA3, 0xD2, 0xA3, 0xD2, 0x1B, 0xCD, 0x1B, 0xCD,
    0x71, 0xC8, 0x72, 0xC8, 0xBC, 0xC4, 0xBC, 0xC4, 0x09, 0xC2, 0x09, 0xC2, 0x66, 0xC0, 0x66, 0xC0,
    0xD9, 0xBF, 0xDA, 0xBF, 0x66, 0xC0, 0x66, 0xC0, 0x09, 0xC2, 0x09, 0xC2, 0xBB, 0xC4, 0xBC, 0xC4,
    0x72, 0xC8, 0x71, 0xC8, 0x1B, 0xCD, 0x1C, 0xCD, 0xA4, 0xD2, 0xA3, 0xD2, 0xF2, 0xD8, 0xF3, 0xD8,
    0xEC, 0xDF, 0xED, 0xDF, 0x73, 0xE7, 0x74, 0xE7, 0x66, 0xEF, 0x66, 0xEF, 0xA1, 0xF7, 0xA1, 0xF7,
    0x00, 0x00, 0x00, 0x00, 0x5F, 0x08, 0x60, 0x08, 0x9B, 0x10, 0x9A, 0x10, 0x8D, 0x18, 0x8C, 0x18,
    0x13, 0x20, 0x13, 0x20, 0x0D, 0x27, 0x0D, 0x27, 0x5C, 0x2D, 0x5D, 0x2D, 0xE5, 0x32, 0xE4, 0x32,
    0x8F, 0x37, 0x8E, 0x37, 0x44, 0x3B, 0x44, 0x3B, 0xF7, 0x3D, 0xF7, 0x3D, 0x9A, 0x3F, 0x99, 0x3F,
    0x27, 0x40, 0x26, 0x40, 0x9A, 0x3F, 0x99, 0x3F, 0xF6, 0x3D, 0xF7, 0x3D, 0x45, 0x3B, 0x44, 0x3B,
    0x8F, 0x37, 0x8E, 0x37, 0xE5, 0x32, 0xE5, 0x32, 0x5C, 0x2D, 0x5D, 0x2D, 0x0E, 0x27, 0x0D, 0x27,
    0x13, 0x20, 0x13, 0x20, 0x8C, 0x18, 0x8D, 0x18, 0x9A, 0x10, 0x9B, 0x10, 0x60, 0x08, 0x60, 0x08,
    0x00, 0x00, 0x00, 0x00, 0xA1, 0xF7, 0xA1, 0xF7, 0x66, 0xEF, 0x65, 0xEF, 0x73, 0xE7, 0x73, 0xE7,
    0xED, 0xDF, 0xEC, 0xDF, 0xF3, 0xD8, 0xF4, 0xD8, 0xA3, 0xD2, 0xA3, 0xD2, 0x1B, 0xCD, 0x1B, 0xCD,
    0x71, 0xC8, 0x72, 0xC8, 0xBC, 0xC4, 0xBC, 0xC4, 0x09, 0xC2, 0x09, 0xC2, 0x66, 0xC0, 0x66, 0xC0,
    0xD9, 0xBF, 0xDA, 0xBF, 0x66, 0xC0, 0x66, 0xC0, 0x09, 0xC2, 0x09, 0xC2, 0xBB, 0xC4, 0xBC, 0xC4,
    0x72, 0xC8, 0x71, 0xC8, 0x1B, 0xCD, 0x1C, 0xCD, 0xA4, 0xD2, 0xA3, 0xD2, 0xF2, 0xD8, 0xF3, 0xD8,
    0xEC, 0xDF, 0xED, 0xDF, 0x73, 0xE7, 0x74, 0xE7, 0x66, 0xEF, 0x66, 0xEF, 0xA1, 0xF7, 0xA1, 0xF7,
    0x00, 0x00, 0x00, 0x00, 0x5F, 0x08, 0x60, 0x08, 0x9B, 0x10, 0x9A, 0x10, 0x8D, 0x18, 0x8C, 0x18,
    0x13, 0x20, 0x13, 0x20, 0x0D, 0x27, 0x0D, 0x27, 0x5C, 0x2D, 0x5D, 0x2D, 0xE5, 0x32, 0xE4, 0x32,
    0x8F, 0x37, 0x8E, 0x37, 0x44, 0x3B, 0x44, 0x3B, 0xF7, 0x3D, 0xF7, 0x3D, 0x9A, 0x3F, 0x99, 0x3F,
    0x27, 0x40, 0x26, 0x40, 0x9A, 0x3F, 0x99, 0x3F, 0xF6, 0x3D, 0xF7, 0x3D, 0x45, 0x3B, 0x44, 0x3B,
    0x8F, 0x37, 0x8E, 0x37, 0xE5, 0x32, 0xE5, 0x32, 0x5C, 0x2D, 0x5D, 0x2D, 0x0E, 0x27, 0x0D, 0x27,
    0x13, 0x20, 0x13, 0x20, 0x8C, 0x18, 0x8D, 0x18, 0x9A, 0x10, 0x9B, 0x10, 0x60, 0x08, 0x60, 0x08,
    0x00, 0x00, 0x00, 0x00, 0xA1, 0xF7, 0xA1, 0xF7, 0x66, 0xEF, 0x65, 0xEF, 0x73, 0xE7, 0x73, 0xE7,
    0xED, 0xDF, 0xEC, 0xDF, 0xF3, 0xD8, 0xF4, 0xD8, 0xA3, 0xD2, 0xA3, 0xD2, 0x1B, 0xCD, 0x1B, 0xCD,
    0x71, 0xC8, 0x72, 0xC8, 0xBC, 0xC4, 0xBC, 0xC4, 0x09, 0xC2, 0x09, 0xC2, 0x66, 0xC0, 0x66, 0xC0,
    0xD9, 0xBF, 0xDA, 0xBF, 0x66, 0xC0, 0x66, 0xC0, 0x09, 0xC2, 0x09, 0xC2, 0xBB, 0xC4, 0xBC, 0xC4,
    0x72, 0xC8, 0x71, 0xC8, 0x1B, 0xCD, 0x1C, 0xCD, 0xA4, 0xD2, 0xA3, 0xD2, 0xF2, 0xD8, 0xF3, 0xD8,
    0xEC, 0xDF, 0xED, 0xDF, 0x73, 0xE7, 0x74, 0xE7, 0x66, 0xEF, 0x66, 0xEF, 0xA1, 0xF7, 0xA1, 0xF7,
    0x00, 0x00, 0x00, 0x00, 0x5F, 0x08, 0x60, 0x08, 0x9B, 0x10, 0x9A, 0x10, 0x8D, 0x18, 0x8C, 0x18,
    0x13, 0x20, 0x13, 0x20, 0x0D, 0x27, 0x0D, 0x27, 0x5C, 0x2D, 0x5D, 0x2D, 0xE5, 0x32, 0xE4, 0x32,
    0x8F, 0x37, 0x8E, 0x37, 0x44, 0x3B, 0x44, 0x3B, 0xF7, 0x3D, 0xF7, 0x3D, 0x9A, 0x3F, 0x99, 0x3F,
    0x27, 0x40, 0x26, 0x40, 0x9A, 0x3F, 0x99, 0x3F, 0xF6, 0x3D, 0xF7, 0x3D, 0x45, 0x3B, 0x44, 0x3B,
    0x8F, 0x37, 0x8E, 0x37, 0xE5, 0x32, 0xE5, 0x32, 0x5C, 0x2D, 0x5D, 0x2D, 0x0E, 0x27, 0x0D, 0x27,
    0x13, 0x20, 0x13, 0x20, 0x8C, 0x18, 0x8D, 0x18, 0x9A, 0x10, 0x9B, 0x10, 0x60, 0x08, 0x60, 0x08,
    0x00, 0x00, 0x00, 0x00, 0xA1, 0xF7, 0xA1, 0xF7, 0x66, 0xEF, 0x65, 0xEF, 0x73, 0xE7, 0x73, 0xE7,
    0xED, 0xDF, 0xEC, 0xDF, 0xF3, 0xD8, 0xF4, 0xD8, 0xA3, 0xD2, 0xA3, 0xD2, 0x1B, 0xCD, 0x1B, 0xCD,
    0x71, 0xC8, 0x72, 0xC8, 0xBC, 0xC4, 0xBC, 0xC4, 0x09, 0xC2, 0x09, 0xC2, 0x66, 0xC0, 0x66, 0xC0,
    0xD9, 0xBF, 0xDA, 0xBF, 0x66, 0xC0, 0x66, 0xC0, 0x09, 0xC2, 0x09, 0xC2, 0xBB, 0xC4, 0xBC, 0xC4,
#if TEST_AO_SPECIAL_SINE
    //
#else
    0x72, 0xC8, 0x71, 0xC8, 0x1B, 0xCD, 0x1C, 0xCD, 0xA4, 0xD2, 0xA3, 0xD2, 0xF2, 0xD8, 0xF3, 0xD8,
    0xEC, 0xDF, 0xED, 0xDF, 0x73, 0xE7, 0x74, 0xE7, 0x66, 0xEF, 0x66, 0xEF, 0xA1, 0xF7, 0xA1, 0xF7
#endif
};
#else
u8 tone_48k[] =
{
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
    0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0x7F,
};
#endif

static u8 tone_48k_mono[] =
{
#if 1 // 1K sine , 48K sample rate
    0x00, 0x00, 0x5F, 0x08, 0x9B, 0x10, 0x8D, 0x18,
    0x13, 0x20, 0x0D, 0x27, 0x5C, 0x2D, 0xE5, 0x32,
    0x8F, 0x37, 0x44, 0x3B, 0xF7, 0x3D, 0x9A, 0x3F,
    0x27, 0x40, 0x9A, 0x3F, 0xF6, 0x3D, 0x45, 0x3B,
    0x8F, 0x37, 0xE5, 0x32, 0x5C, 0x2D, 0x0E, 0x27,
    0x13, 0x20, 0x8C, 0x18, 0x9A, 0x10, 0x60, 0x08,
    0x00, 0x00, 0xA1, 0xF7, 0x66, 0xEF, 0x73, 0xE7,
    0xED, 0xDF, 0xF3, 0xD8, 0xA3, 0xD2, 0x1B, 0xCD,
    0x71, 0xC8, 0xBC, 0xC4, 0x09, 0xC2, 0x66, 0xC0,
    0xD9, 0xBF, 0x66, 0xC0, 0x09, 0xC2, 0xBB, 0xC4,
    0x72, 0xC8, 0x1B, 0xCD, 0xA4, 0xD2, 0xF2, 0xD8,
    0xEC, 0xDF, 0x73, 0xE7, 0x66, 0xEF, 0xA1, 0xF7,

    0x00, 0x00, 0x5F, 0x08, 0x9B, 0x10, 0x8D, 0x18,
    0x13, 0x20, 0x0D, 0x27, 0x5C, 0x2D, 0xE5, 0x32,
    0x8F, 0x37, 0x44, 0x3B, 0xF7, 0x3D, 0x9A, 0x3F,
    0x27, 0x40, 0x9A, 0x3F, 0xF6, 0x3D, 0x45, 0x3B,
    0x8F, 0x37, 0xE5, 0x32, 0x5C, 0x2D, 0x0E, 0x27,
    0x13, 0x20, 0x8C, 0x18, 0x9A, 0x10, 0x60, 0x08,
    0x00, 0x00, 0xA1, 0xF7, 0x66, 0xEF, 0x73, 0xE7,
    0xED, 0xDF, 0xF3, 0xD8, 0xA3, 0xD2, 0x1B, 0xCD,
    0x71, 0xC8, 0xBC, 0xC4, 0x09, 0xC2, 0x66, 0xC0,
    0xD9, 0xBF, 0x66, 0xC0, 0x09, 0xC2, 0xBB, 0xC4,
    0x72, 0xC8, 0x1B, 0xCD, 0xA4, 0xD2, 0xF2, 0xD8,
    0xEC, 0xDF, 0x73, 0xE7, 0x66, 0xEF, 0xA1, 0xF7,

    0x00, 0x00, 0x5F, 0x08, 0x9B, 0x10, 0x8D, 0x18,
    0x13, 0x20, 0x0D, 0x27, 0x5C, 0x2D, 0xE5, 0x32,
    0x8F, 0x37, 0x44, 0x3B, 0xF7, 0x3D, 0x9A, 0x3F,
    0x27, 0x40, 0x9A, 0x3F, 0xF6, 0x3D, 0x45, 0x3B,
    0x8F, 0x37, 0xE5, 0x32, 0x5C, 0x2D, 0x0E, 0x27,
    0x13, 0x20, 0x8C, 0x18, 0x9A, 0x10, 0x60, 0x08,
    0x00, 0x00, 0xA1, 0xF7, 0x66, 0xEF, 0x73, 0xE7,
    0xED, 0xDF, 0xF3, 0xD8, 0xA3, 0xD2, 0x1B, 0xCD,
    0x71, 0xC8, 0xBC, 0xC4, 0x09, 0xC2, 0x66, 0xC0,
    0xD9, 0xBF, 0x66, 0xC0, 0x09, 0xC2, 0xBB, 0xC4,
    0x72, 0xC8, 0x1B, 0xCD, 0xA4, 0xD2, 0xF2, 0xD8,
    0xEC, 0xDF, 0x73, 0xE7, 0x66, 0xEF, 0xA1, 0xF7,

    0x00, 0x00, 0x5F, 0x08, 0x9B, 0x10, 0x8D, 0x18,
    0x13, 0x20, 0x0D, 0x27, 0x5C, 0x2D, 0xE5, 0x32,
    0x8F, 0x37, 0x44, 0x3B, 0xF7, 0x3D, 0x9A, 0x3F,
    0x27, 0x40, 0x9A, 0x3F, 0xF6, 0x3D, 0x45, 0x3B,
    0x8F, 0x37, 0xE5, 0x32, 0x5C, 0x2D, 0x0E, 0x27,
    0x13, 0x20, 0x8C, 0x18, 0x9A, 0x10, 0x60, 0x08,
    0x00, 0x00, 0xA1, 0xF7, 0x66, 0xEF, 0x73, 0xE7,
    0xED, 0xDF, 0xF3, 0xD8, 0xA3, 0xD2, 0x1B, 0xCD,
    0x71, 0xC8, 0xBC, 0xC4, 0x09, 0xC2, 0x66, 0xC0,
    0xD9, 0xBF, 0x66, 0xC0, 0x09, 0xC2, 0xBB, 0xC4,
    0x72, 0xC8, 0x1B, 0xCD, 0xA4, 0xD2, 0xF2, 0xD8,
    0xEC, 0xDF, 0x73, 0xE7, 0x66, 0xEF, 0xA1, 0xF7,

    0x00, 0x00, 0x5F, 0x08, 0x9B, 0x10, 0x8D, 0x18,
    0x13, 0x20, 0x0D, 0x27, 0x5C, 0x2D, 0xE5, 0x32,
    0x8F, 0x37, 0x44, 0x3B, 0xF7, 0x3D, 0x9A, 0x3F,
    0x27, 0x40, 0x9A, 0x3F, 0xF6, 0x3D, 0x45, 0x3B,
    0x8F, 0x37, 0xE5, 0x32, 0x5C, 0x2D, 0x0E, 0x27,
    0x13, 0x20, 0x8C, 0x18, 0x9A, 0x10, 0x60, 0x08,
    0x00, 0x00, 0xA1, 0xF7, 0x66, 0xEF, 0x73, 0xE7,
    0xED, 0xDF, 0xF3, 0xD8, 0xA3, 0xD2, 0x1B, 0xCD,
    0x71, 0xC8, 0xBC, 0xC4, 0x09, 0xC2, 0x66, 0xC0,
    0xD9, 0xBF, 0x66, 0xC0, 0x09, 0xC2, 0xBB, 0xC4,
    0x72, 0xC8, 0x1B, 0xCD, 0xA4, 0xD2, 0xF2, 0xD8,
    0xEC, 0xDF, 0x73, 0xE7, 0x66, 0xEF, 0xA1, 0xF7,

    0x00, 0x00, 0x5F, 0x08, 0x9B, 0x10, 0x8D, 0x18,
    0x13, 0x20, 0x0D, 0x27, 0x5C, 0x2D, 0xE5, 0x32,
    0x8F, 0x37, 0x44, 0x3B, 0xF7, 0x3D, 0x9A, 0x3F,
    0x27, 0x40, 0x9A, 0x3F, 0xF6, 0x3D, 0x45, 0x3B,
    0x8F, 0x37, 0xE5, 0x32, 0x5C, 0x2D, 0x0E, 0x27,
    0x13, 0x20, 0x8C, 0x18, 0x9A, 0x10, 0x60, 0x08,
    0x00, 0x00, 0xA1, 0xF7, 0x66, 0xEF, 0x73, 0xE7,
    0xED, 0xDF, 0xF3, 0xD8, 0xA3, 0xD2, 0x1B, 0xCD,
    0x71, 0xC8, 0xBC, 0xC4, 0x09, 0xC2, 0x66, 0xC0,

#if TEST_AO_SPECIAL_SINE
    //
#else
    0xD9, 0xBF, 0x66, 0xC0, 0x09, 0xC2, 0xBB, 0xC4,
    0x72, 0xC8, 0x1B, 0xCD, 0xA4, 0xD2, 0xF2, 0xD8,
    0xEC, 0xDF, 0x73, 0xE7, 0x66, 0xEF, 0xA1, 0xF7,
#endif

#else
    0x00, 0x00, 0xf9, 0x18, 0xfb, 0x30, 0x1c, 0x47,
    0x82, 0x5a, 0x6d, 0x6a, 0x41, 0x76, 0x8a, 0x7d,
    0xff, 0x7f, 0x8b, 0x7d, 0x42, 0x76, 0x6f, 0x6a,
    0x84, 0x5a, 0x1f, 0x47, 0xfe, 0x30, 0xfc, 0x18,
    0x03, 0x00, 0x0a, 0xe7, 0x07, 0xcf, 0xe6, 0xb8,
    0x80, 0xa5, 0x95, 0x95, 0xc0, 0x89, 0x76, 0x82,
    0x00, 0x80, 0x75, 0x82, 0xbc, 0x89, 0x90, 0x95,
    0x7a, 0xa5, 0xde, 0xb8, 0xff, 0xce, 0x02, 0xe7,
    0x00, 0x00, 0xf9, 0x18, 0xfb, 0x30, 0x1c, 0x47,
    0x82, 0x5a, 0x6d, 0x6a, 0x41, 0x76, 0x8a, 0x7d,
    0xff, 0x7f, 0x8b, 0x7d, 0x42, 0x76, 0x6f, 0x6a,
    0x84, 0x5a, 0x1f, 0x47, 0xfe, 0x30, 0xfc, 0x18,
    0x03, 0x00, 0x0a, 0xe7, 0x07, 0xcf, 0xe6, 0xb8,
    0x80, 0xa5, 0x95, 0x95, 0xc0, 0x89, 0x76, 0x82,
    0x00, 0x80, 0x75, 0x82, 0xbc, 0x89, 0x90, 0x95,
    0x7a, 0xa5, 0xde, 0xb8, 0xff, 0xce, 0x02, 0xe7,
    0x00, 0x00, 0xf9, 0x18, 0xfb, 0x30, 0x1c, 0x47,
    0x82, 0x5a, 0x6d, 0x6a, 0x41, 0x76, 0x8a, 0x7d,
    0xff, 0x7f, 0x8b, 0x7d, 0x42, 0x76, 0x6f, 0x6a,
    0x84, 0x5a, 0x1f, 0x47, 0xfe, 0x30, 0xfc, 0x18,
    0x03, 0x00, 0x0a, 0xe7, 0x07, 0xcf, 0xe6, 0xb8,
    0x80, 0xa5, 0x95, 0x95, 0xc0, 0x89, 0x76, 0x82,
    0x00, 0x80, 0x75, 0x82, 0xbc, 0x89, 0x90, 0x95,
    0x7a, 0xa5, 0xde, 0xb8, 0xff, 0xce, 0x02, 0xe7,
    0x00, 0x00, 0xf9, 0x18, 0xfb, 0x30, 0x1c, 0x47,
    0x82, 0x5a, 0x6d, 0x6a, 0x41, 0x76, 0x8a, 0x7d,
    0xff, 0x7f, 0x8b, 0x7d, 0x42, 0x76, 0x6f, 0x6a,
    0x84, 0x5a, 0x1f, 0x47, 0xfe, 0x30, 0xfc, 0x18,
    0x03, 0x00, 0x0a, 0xe7, 0x07, 0xcf, 0xe6, 0xb8,
    0x80, 0xa5, 0x95, 0x95, 0xc0, 0x89, 0x76, 0x82,
    0x00, 0x80, 0x75, 0x82, 0xbc, 0x89, 0x90, 0x95,
    0x7a, 0xa5, 0xde, 0xb8, 0xff, 0xce, 0x02, 0xe7
#endif
};

static u8 tone_48k_noninterleave[] =
{
    0x00, 0x00, 0xf9, 0x18, 0xfb, 0x30, 0x1c, 0x47,
    0x82, 0x5a, 0x6d, 0x6a, 0x41, 0x76, 0x8a, 0x7d,
    0xff, 0x7f, 0x8b, 0x7d, 0x42, 0x76, 0x6f, 0x6a,
    0x84, 0x5a, 0x1f, 0x47, 0xfe, 0x30, 0xfc, 0x18,
    0x03, 0x00, 0x0a, 0xe7, 0x07, 0xcf, 0xe6, 0xb8,
    0x80, 0xa5, 0x95, 0x95, 0xc0, 0x89, 0x76, 0x82,
    0x00, 0x80, 0x75, 0x82, 0xbc, 0x89, 0x90, 0x95,
    0x7a, 0xa5, 0xde, 0xb8, 0xff, 0xce, 0x02, 0xe7,
    0x00, 0x00, 0xf9, 0x18, 0xfb, 0x30, 0x1c, 0x47,
    0x82, 0x5a, 0x6d, 0x6a, 0x41, 0x76, 0x8a, 0x7d,
    0xff, 0x7f, 0x8b, 0x7d, 0x42, 0x76, 0x6f, 0x6a,
    0x84, 0x5a, 0x1f, 0x47, 0xfe, 0x30, 0xfc, 0x18,
    0x03, 0x00, 0x0a, 0xe7, 0x07, 0xcf, 0xe6, 0xb8,
    0x80, 0xa5, 0x95, 0x95, 0xc0, 0x89, 0x76, 0x82,
    0x00, 0x80, 0x75, 0x82, 0xbc, 0x89, 0x90, 0x95,
    0x7a, 0xa5, 0xde, 0xb8, 0xff, 0xce, 0x02, 0xe7,
    0x00, 0x00, 0xf9, 0x18, 0xfb, 0x30, 0x1c, 0x47,
    0x82, 0x5a, 0x6d, 0x6a, 0x41, 0x76, 0x8a, 0x7d,
    0xff, 0x7f, 0x8b, 0x7d, 0x42, 0x76, 0x6f, 0x6a,
    0x84, 0x5a, 0x1f, 0x47, 0xfe, 0x30, 0xfc, 0x18,
    0x03, 0x00, 0x0a, 0xe7, 0x07, 0xcf, 0xe6, 0xb8,
    0x80, 0xa5, 0x95, 0x95, 0xc0, 0x89, 0x76, 0x82,
    0x00, 0x80, 0x75, 0x82, 0xbc, 0x89, 0x90, 0x95,
    0x7a, 0xa5, 0xde, 0xb8, 0xff, 0xce, 0x02, 0xe7,
    0x00, 0x00, 0xf9, 0x18, 0xfb, 0x30, 0x1c, 0x47,
    0x82, 0x5a, 0x6d, 0x6a, 0x41, 0x76, 0x8a, 0x7d,
    0xff, 0x7f, 0x8b, 0x7d, 0x42, 0x76, 0x6f, 0x6a,
    0x84, 0x5a, 0x1f, 0x47, 0xfe, 0x30, 0xfc, 0x18,
    0x03, 0x00, 0x0a, 0xe7, 0x07, 0xcf, 0xe6, 0xb8,
    0x80, 0xa5, 0x95, 0x95, 0xc0, 0x89, 0x76, 0x82,
    0x00, 0x80, 0x75, 0x82, 0xbc, 0x89, 0x90, 0x95,
    0x7a, 0xa5, 0xde, 0xb8, 0xff, 0xce, 0x02, 0xe7,
    0x00, 0x00, 0xf9, 0x18, 0xfb, 0x30, 0x1c, 0x47,
    0x82, 0x5a, 0x6d, 0x6a, 0x41, 0x76, 0x8a, 0x7d,
    0xff, 0x7f, 0x8b, 0x7d, 0x42, 0x76, 0x6f, 0x6a,
    0x84, 0x5a, 0x1f, 0x47, 0xfe, 0x30, 0xfc, 0x18,
    0x03, 0x00, 0x0a, 0xe7, 0x07, 0xcf, 0xe6, 0xb8,
    0x80, 0xa5, 0x95, 0x95, 0xc0, 0x89, 0x76, 0x82,
    0x00, 0x80, 0x75, 0x82, 0xbc, 0x89, 0x90, 0x95,
    0x7a, 0xa5, 0xde, 0xb8, 0xff, 0xce, 0x02, 0xe7,
    0x00, 0x00, 0xf9, 0x18, 0xfb, 0x30, 0x1c, 0x47,
    0x82, 0x5a, 0x6d, 0x6a, 0x41, 0x76, 0x8a, 0x7d,
    0xff, 0x7f, 0x8b, 0x7d, 0x42, 0x76, 0x6f, 0x6a,
    0x84, 0x5a, 0x1f, 0x47, 0xfe, 0x30, 0xfc, 0x18,
    0x03, 0x00, 0x0a, 0xe7, 0x07, 0xcf, 0xe6, 0xb8,
    0x80, 0xa5, 0x95, 0x95, 0xc0, 0x89, 0x76, 0x82,
    0x00, 0x80, 0x75, 0x82, 0xbc, 0x89, 0x90, 0x95,
    0x7a, 0xa5, 0xde, 0xb8, 0xff, 0xce, 0x02, 0xe7,
    0x00, 0x00, 0xf9, 0x18, 0xfb, 0x30, 0x1c, 0x47,
    0x82, 0x5a, 0x6d, 0x6a, 0x41, 0x76, 0x8a, 0x7d,
    0xff, 0x7f, 0x8b, 0x7d, 0x42, 0x76, 0x6f, 0x6a,
    0x84, 0x5a, 0x1f, 0x47, 0xfe, 0x30, 0xfc, 0x18,
    0x03, 0x00, 0x0a, 0xe7, 0x07, 0xcf, 0xe6, 0xb8,
    0x80, 0xa5, 0x95, 0x95, 0xc0, 0x89, 0x76, 0x82,
    0x00, 0x80, 0x75, 0x82, 0xbc, 0x89, 0x90, 0x95,
    0x7a, 0xa5, 0xde, 0xb8, 0xff, 0xce, 0x02, 0xe7,
    0x00, 0x00, 0xf9, 0x18, 0xfb, 0x30, 0x1c, 0x47,
    0x82, 0x5a, 0x6d, 0x6a, 0x41, 0x76, 0x8a, 0x7d,
    0xff, 0x7f, 0x8b, 0x7d, 0x42, 0x76, 0x6f, 0x6a,
    0x84, 0x5a, 0x1f, 0x47, 0xfe, 0x30, 0xfc, 0x18,
    0x03, 0x00, 0x0a, 0xe7, 0x07, 0xcf, 0xe6, 0xb8,
    0x80, 0xa5, 0x95, 0x95, 0xc0, 0x89, 0x76, 0x82,
    0x00, 0x80, 0x75, 0x82, 0xbc, 0x89, 0x90, 0x95,
    0x7a, 0xa5, 0xde, 0xb8, 0xff, 0xce, 0x02, 0xe7
};

struct pcm_hardware
{
    unsigned int rate_min;		/* min rate */
    unsigned int rate_max;		/* max rate */
    unsigned int channels_min;	/* min channels */
    unsigned int channels_max;	/* max channels */
    size_t buffer_bytes_max;	/* max buffer size */
    size_t period_bytes_min;	/* min period size */
    size_t period_bytes_max;	/* max period size */
    unsigned int periods_min;	/* min # of periods */
    unsigned int periods_max;	/* max # of periods */
};

struct pcm_data
{
    unsigned int dev_id;
    unsigned int playback;
    long(*DrvAudioIoctlParse)(struct file *filp, unsigned int u32Cmd, unsigned long u32Arg);
};

/*static struct pcm_hardware pcm_playback_hardware =
{
  .rate_min			= 8000,
  .rate_max			= 48000,
  .channels_min		= 1,
  .channels_max		= 2,
  .buffer_bytes_max	= 96 * 1024,
  .period_bytes_min	= 2 * 1024,
  .period_bytes_max	= 24 * 1024,
  .periods_min		= 4,
  .periods_max		= 8,
};*/



static void* alloc_dmem(const char* name, unsigned int size, dma_addr_t *addr)
{
    MSYS_DMEM_INFO dmem;
    memcpy(dmem.name,name,strlen(name)+1);
    dmem.length=size;
    if(0!=msys_request_dmem(&dmem))
    {
        return NULL;
    }
    *addr=dmem.phys;
    return (void *)((uintptr_t)dmem.kvirt);
}

static void free_dmem(const char* name, unsigned int size, void *virt, dma_addr_t addr)
{
    MSYS_DMEM_INFO dmem;
    memcpy(dmem.name,name,strlen(name)+1);
    dmem.length=size;
    dmem.kvirt=(unsigned long long)((uintptr_t)virt);
    dmem.phys=(unsigned long long)((uintptr_t)addr);
    msys_release_dmem(&dmem);
}

static void getDevAttr(int nMinor, int *pbPlay, int *pnDev)
{
    if(nMinor<AUDIO_IN_DEV)
    {
        *pbPlay = FALSE;
        *pnDev = nMinor;
    }
    else
    {
        *pbPlay = TRUE;
        *pnDev = nMinor-AUDIO_IN_DEV;
    }
}

struct dma_buffer
{
    unsigned char *area;	/* virtual pointer */
    dma_addr_t addr;	/* physical address */
    size_t bytes;		/* buffer size in bytes */
};

struct dma_buffer buf;
struct dma_buffer buf_AO;
struct dma_buffer buf_bench;



static u8 use_thread = 1;

typedef struct ao_info
{
    int     dev;
    int     total_size;
    u8      *pDataArray;
    int     nArrSize;
    int     nStartThres;
    char    play_wav;
    char    fileName[100];

} _AO_Info_t;

typedef struct ai_info
{
    int     dev;
    int     total_size;
    int     channelSize;
    int     channels;
    int     tmpBufSize;
    u8      *tmpBuf;
    int     interleaved;
    int     nSpecialDumpChannels;

} _AI_Info_t;

typedef struct WAVE_FORMAT
{
    signed short wFormatTag;
    signed short wChannels;
    unsigned int dwSamplesPerSec;
    unsigned int dwAvgBytesPerSec;
    signed short wBlockAlign;
    signed short wBitsPerSample;
} WaveFormat_t;

typedef struct WAVEFILEHEADER
{
    char chRIFF[4];
    unsigned int  dwRIFFLen;
    char chWAVE[4];
    char chFMT[4];
    unsigned int  dwFMTLen;
    WaveFormat_t wave;
    char chDATA[4];
    unsigned int  dwDATALen;
} WaveFileHeader_t;

static struct task_struct *ao_thread;
static struct task_struct *ai_thread;

static u8 ao_thread_finish_flag = 0;
static u8 ai_thread_finish_flag = 0;

static WaveFileHeader_t stWavHeaderInput;

#define AUDIO_SAMPLE_PER_FRAME	(1024)

char u8TempBuf[AUDIO_SAMPLE_PER_FRAME * 4];

int _AoRun(void* data)
{
    //
    _AO_Info_t* pstAoInfo = (_AO_Info_t*)data;

    //
    int size = 0;
    int flag = 1;
    int ret = 0;

    //
    int     dev;
    int     total_size;
    u8      *pDataArray;
    int     nArrSize;
    int     nStartThres;

    //
    dev = pstAoInfo->dev;
    total_size = pstAoInfo->total_size;
    pDataArray = pstAoInfo->pDataArray;
    nArrSize = pstAoInfo->nArrSize;
    nStartThres = pstAoInfo->nStartThres;

    //
    while(total_size>nArrSize)
    {
        if (pstAoInfo->play_wav)
        {
            pDataArray = u8TempBuf;
            ret = vfs_read(ao_file, (char *)pDataArray, nArrSize, &ao_file->f_pos);
            if (ret != nArrSize)
            {
                ao_file->f_pos = sizeof(WaveFileHeader_t);
                ret = vfs_read(ao_file, (char *)u8TempBuf, nArrSize, &ao_file->f_pos);
                if (ret < 0)
                {
                    AUD_UT_PRINTF(ERROR_UT_LEVEL, "Input file does not has enough data!\n");
                    break;
                }
            }
        }

        if ( (size>=nStartThres) && (flag==1) )
        {
            ret = MHAL_AUDIO_StartPcmOut(dev);
            if ( ret )
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL,"MHAL_AUDIO_StartPcmOut fail !!! ret = %d\n",ret);
                return 0;
            }
            else
            {
                AUD_UT_PRINTF(LOG_UT_LEVEL,"AO DMA Start ! current size = %d\n",size);
            }

            flag = 0;
        }

#if TEST_AO_EMPTY
        {
            static int c = 1;

            if ( flag == 1 )
            {
                c = 1;
            }
            else
            {
                c++;
                CamOsMsSleep(10*c);
            }
        }
#endif
        ret = MHAL_AUDIO_WriteDataOut(dev, pDataArray, nArrSize, TRUE); // FALSE
        if ( ret >= 0 )
        {
            size += nArrSize;
            total_size -= nArrSize;
        }
        else
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL,"MHAL_AUDIO_WriteDataOut fail !!! ret = %d\n",ret);

            if ( MHAL_AUDIO_IsPcmOutXrun(dev) )
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL,"AO Empty ! XRUN !!!\n");
                flag = 1;
                size = 0;
            }
        }

#if TEST_AO_HOT_STOP
        {
            int nCurrLen = 0;

            if (size>=(nStartThres*4))
            {
                MHAL_AUDIO_GetPcmOutCurrDataLen(dev,&nCurrLen);

                AUD_UT_PRINTF(LOG_UT_LEVEL,"When Stop, nCurrLen = %d\n",nCurrLen);

                ret = MHAL_AUDIO_StopPcmOut(dev);
                if(ret)
                {
                    AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_StopPcmOut error=%d!!!\n",ret);
                    //return -EFAULT;
                }

                return 0;
            }
        }
#endif
    }

    if ( flag == 0 )
    {
        while( !MHAL_AUDIO_IsPcmOutXrun(dev) )
        {
            CamOsMsSleep(1);
        }
    }

    return 0;
}

int _AiRun(void* data)
{
    //
    _AI_Info_t* pstAiInfo = (_AI_Info_t*)data;

    //
    int size = 0;
    int ret = 0;
    int count = 0;
    int i = 0, j = 0;

    //
    int dev;
    int total_size;
    u8 *tmpBuf;
    int tmpBufSize;
    int channels;
    int channelSize;
    int interleaved;
    int nSpecialDumpChannels;

#if TEST_AI_FULL
    static int c = 1, pre_c = 0;
#endif

    //
    dev = pstAiInfo->dev;
    total_size = pstAiInfo->total_size;
    tmpBuf = pstAiInfo->tmpBuf;
    tmpBufSize = pstAiInfo->tmpBufSize;
    channels = pstAiInfo->channels;
    channelSize = pstAiInfo->channelSize;
    interleaved = pstAiInfo->interleaved;
    nSpecialDumpChannels = pstAiInfo->nSpecialDumpChannels;

    //
    fs = get_fs();
    set_fs(KERNEL_DS);

    //
    ret = MHAL_AUDIO_StartPcmIn(dev);
    if(ret)
    {
        AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_StartPcmIn fail !!! ret = %d\n",ret);
        goto fail;
    }
    else
    {
        AUD_UT_PRINTF(LOG_UT_LEVEL, "AI DMA Start !\n");
    }

    while(count<total_size)
    {
        if (MHAL_AUDIO_IsPcmInXrun(dev))
        {
#if TEST_AI_FULL
            c = 1;
#endif
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "AI Full ! XRUN !!!, count = %d\n",count);

            ret = MHAL_AUDIO_StartPcmIn(dev);
            if(ret)
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_StartPcmIn fail !!! ret = %d\n",ret);
                goto fail;
            }
            else
            {
                AUD_UT_PRINTF(LOG_UT_LEVEL, "AI DMA Start Re-Start !!!\n");
            }
        }

#if TEST_AI_FULL
        if ( pre_c < 100 )
        {
            pre_c++;
        }
        else
        {
            c++;
            CamOsMsSleep(c);
        }
#endif

        //
        if ( nSpecialDumpChannels == 0 ) // We don't yet handle the case that DC = 0.
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "nSpecialDumpChannels == 0 !!!\n");
            goto fail;
        }

        //
        ret = MHAL_AUDIO_ReadDataIn(dev, tmpBuf, tmpBufSize, TRUE);
        if (ret<0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_ReadDataIn fail !!!, ret = %d\n",ret);
        }
        else
        {
            if(interleaved)
            {
                if ( nSpecialDumpChannels != 0 )
                {
                    for ( j = 0; (channelSize*j*nSpecialDumpChannels) < ret; j++ )
                    {
                        for ( i = 0; i < nSpecialDumpChannels; i++ )
                        {
                            size = vfs_write((*(fw+i)), (char *)tmpBuf+(channelSize*i)+(channelSize*j*nSpecialDumpChannels), channelSize, &(*(fw+i))->f_pos);
                            count += size;
                        }
                    }
                }
            }
            else
            {
                if ( nSpecialDumpChannels != 0 )
                {
                    for(i=0; i<nSpecialDumpChannels; i++)
                    {
                        size = vfs_write((*(fw+i)), (char *)tmpBuf+(ret/nSpecialDumpChannels)*i, ret/nSpecialDumpChannels, &(*(fw+i))->f_pos);
                        if ( size!=ret/nSpecialDumpChannels )
                        {
                            AUD_UT_PRINTF(ERROR_UT_LEVEL, "Dump file write data length is wrong !!!, size = %d, write = %d\n",size,ret/nSpecialDumpChannels);
                        }
                    }
                    count += ret;
                }
            }
        }
    }

    //
    AUD_UT_PRINTF(LOG_UT_LEVEL, "Dump file ok %d bytes!!!\n",count);

fail:

    //
    set_fs(fs);

    return 0;
}


int _AoThread(void* data)
{
    int finish = 0;

    //
    while(!kthread_should_stop())
    {
        if ( finish != 0 )
        {
            CamOsMsSleep(10);
            continue;
        }

        _AoRun( data );

        //
        finish = 1;
        ao_thread_finish_flag = 1;
        AUD_UT_PRINTF(TRACE_UT_LEVEL,"Ao Thread Ready to Finsh !\n");
    }

    return 1;
}

int _AiThread(void* data)
{
    int finish = 0;

    while(!kthread_should_stop())
    {
        if ( finish != 0 )
        {
            CamOsMsSleep(10);
            continue;
        }

        _AiRun( data );

        //
        finish = 1;
        ai_thread_finish_flag = 1;
        AUD_UT_PRINTF(TRACE_UT_LEVEL,"Ai Thread Ready to Finsh !\n");
    }

    return 1;
}

static long AudioCapIoctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    struct AUD_PcmCfg_s sPcmCfg;
    struct AUD_GainCfg_s sGainCfg;
    MHAL_AUDIO_PcmCfg_t tPcm;
    MHAL_AUDIO_I2sCfg_t tI2sCfg;
    MHAL_AUDIO_SineGenCfg_t tSineGenCfg;
    struct pcm_data *pPcmData = (struct pcm_data *)filp->private_data;
    int dev = pPcmData->dev_id;
    int ret;
    u8 tmpBuf[2048];
    u8 channelSize[2];
    int total_size;
    int i;
    char fn[50];
    _AI_Info_t stAiInfo;

    // For Bench
    struct AUD_BenchRead_s sBenchRead;

    //
    switch(cmd)
    {
    case AUDRV_PCM_TEST:
    {
        if (copy_from_user(&sPcmCfg, (void __user *)arg,sizeof(sPcmCfg))!=0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_PCM_TEST arg error!!!\n");
            return -EFAULT;
        }
        else
        {
            AUD_UT_PRINTF(TRACE_UT_LEVEL, "AUDRV_PCM_TEST arg get!!!\n");
        }

        if(((1 != sPcmCfg.n16Channels) && (0 != sPcmCfg.n16Channels%2)) || (8 < sPcmCfg.n16Channels))
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "Channels set error!!. \n");
            return -1;
        }

        // File Open
        if ( sPcmCfg.nSpecialDumpChannels != 0 )
        {
            fw = (struct file**)kmalloc(sizeof(struct file*)*sPcmCfg.nSpecialDumpChannels,GFP_KERNEL);

            for(i=0; i<sPcmCfg.nSpecialDumpChannels; i++)
            {
                sprintf(fn,"/tmp/dump_%d_ch%d_%d.pcm", sPcmCfg.nRate, i, sPcmCfg.nBitWidth);
                *(fw+i) = filp_open(fn, O_RDWR | O_CREAT, 0644);

                if(IS_ERR(*(fw+i)))
                {
                    AUD_UT_PRINTF(ERROR_UT_LEVEL, "Test: filp_open error!!. \n");
                    return -1;
                }
            }
        }
        else
        {
            fw = (struct file**)kmalloc(sizeof(struct file*)*sPcmCfg.n16Channels,GFP_KERNEL);

            if(sPcmCfg.nInterleaved)
            {
                //fw = (struct file**)kmalloc(sizeof(struct file*),GFP_KERNEL);

                if(sPcmCfg.n16Channels == 4)
                {
                    for(i=0; i<sPcmCfg.n16Channels/2; i++)
                    {
                        sprintf(fn,"/tmp/rec_%d_ch%d%d_%d.pcm", sPcmCfg.nRate, i*2, (i*2)+1, sPcmCfg.nBitWidth);
                        *(fw+i) = filp_open(fn, O_RDWR | O_CREAT, 0644);

                        if(IS_ERR(*(fw+i)))
                        {
                            AUD_UT_PRINTF(ERROR_UT_LEVEL, "Test: filp_open error!!. \n");
                            return -1;
                        }
                    }
                }
                else
                {
                    sprintf(fn,"/tmp/rec_%d_%dch_%d.pcm",sPcmCfg.nRate,sPcmCfg.n16Channels,sPcmCfg.nBitWidth);
                    *fw = filp_open(fn, O_RDWR | O_CREAT, 0644);

                    if(IS_ERR(*fw))
                    {
                        AUD_UT_PRINTF(ERROR_UT_LEVEL, "Test: filp_open error!!. \n");
                        return -1;
                    }
                }
            }
            else
            {
                //fw = (struct file**)kmalloc(sizeof(struct file*)*sPcmCfg.n16Channels,GFP_KERNEL);
                for(i=0; i<sPcmCfg.n16Channels; i++)
                {
                    sprintf(fn,"/tmp/rec_%d_ch%d_%d.pcm",sPcmCfg.nRate,i,sPcmCfg.nBitWidth);
                    *(fw+i) = filp_open(fn, O_RDWR | O_CREAT, 0644);

                    if(IS_ERR(*(fw+i)))
                    {
                        AUD_UT_PRINTF(ERROR_UT_LEVEL, "Test: filp_open error!!. \n");
                        return -1;
                    }
                }
            }
        }

        //
        if(sPcmCfg.nRate==8000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_8K;
        else if(sPcmCfg.nRate==16000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_16K;
        else if(sPcmCfg.nRate==32000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_32K;
        else if(sPcmCfg.nRate==48000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_48K;
        else
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_PCM_IOCTL sample rate %d not support!!!\n",sPcmCfg.nRate);
            return -EFAULT;
        }

        if(sPcmCfg.nBitWidth==16)
            tPcm.eWidth = E_MHAL_AUDIO_BITWIDTH_16;
        else if(sPcmCfg.nBitWidth==32)
            tPcm.eWidth = E_MHAL_AUDIO_BITWIDTH_32;
        else
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_PCM_IOCTL bitwidth %d not support!!!\n",sPcmCfg.nBitWidth);
            return -EFAULT;
        }
        tPcm.u16Channels = sPcmCfg.n16Channels;
        tPcm.bInterleaved = sPcmCfg.nInterleaved;
        tPcm.pu8DmaArea = buf.area;
        tPcm.phyDmaAddr = buf.addr-MIU_OFFSET;
        tPcm.u32BufferSize = buf.bytes;
        tPcm.u32PeriodSize = sPcmCfg.n32PeriodSize;//7680;//1024*2*2*6;
        tPcm.u32StartThres = sPcmCfg.n32StartThres;//buf.bytes+1;//buf.bytes/2;

        if(sPcmCfg.nI2sConfig)
        {
            if(sPcmCfg.sI2s.nTdmMode==1)
            {
                if(sPcmCfg.sI2s.nMsMode==0)
                {
                    tI2sCfg.eMode = E_MHAL_AUDIO_MODE_TDM_MASTER;
                }
                else
                {
                    tI2sCfg.eMode = E_MHAL_AUDIO_MODE_TDM_SLAVE;
                }
            }
            else if(sPcmCfg.sI2s.nTdmMode==0)
            {
                if(sPcmCfg.sI2s.nMsMode==0)
                {
                    tI2sCfg.eMode = E_MHAL_AUDIO_MODE_I2S_MASTER;
                }
                else
                {
                    tI2sCfg.eMode = E_MHAL_AUDIO_MODE_I2S_SLAVE;
                }
            }
            else
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_PCM_IOCTL I2S mode not support!!!\n");
                return -EFAULT;
            }

            tI2sCfg.eWidth = (sPcmCfg.sI2s.nBitWidth?E_MHAL_AUDIO_BITWIDTH_32:E_MHAL_AUDIO_BITWIDTH_16);

            tI2sCfg.eFmt = (sPcmCfg.sI2s.nFmt?E_MHAL_AUDIO_I2S_FMT_LEFT_JUSTIFY:E_MHAL_AUDIO_I2S_FMT_I2S);

            tI2sCfg.u16Channels = sPcmCfg.sI2s.u16Channels;

            tI2sCfg.eMck = sPcmCfg.sI2s.eMck;

            tI2sCfg.e4WireMode = sPcmCfg.sI2s.e4WireMode;

            tI2sCfg.eRate = tPcm.eRate;

            ret=MHAL_AUDIO_ConfigI2sIn(dev, &tI2sCfg);
            if(ret)
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL,"MHAL_AUDIO_ConfigI2sIn error=%d!!!\n",ret);
                return -EFAULT;
            }
        }

        //
        total_size = sPcmCfg.nTimeMs*(sPcmCfg.nRate/1000)*sPcmCfg.n16Channels*(sPcmCfg.nBitWidth/8);

        AUD_UT_PRINTF(LOG_UT_LEVEL, "AI total_size %d!!!\n",total_size);

        ret = MHAL_AUDIO_ConfigPcmIn(dev, &tPcm);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_ConfigPcmIn error=%d!!!\n",ret);
            return -EFAULT;
        }
        ret = MHAL_AUDIO_OpenPcmIn(dev);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_OpenPcmIn error=%d!!!\n",ret);
            goto fail;
        }

#if TEST_DPGA_GAIN_FADING
#if TEST_FADING_AI
        if ((MHAL_AUDIO_SetGainIn(dev, 0, 0) != 0) || (MHAL_AUDIO_SetGainIn(dev, 0, 1) != 0))
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "TEST_DPGA_GAIN_FADING - MHAL_AUDIO_SetGainIn fail !!!\n");
            return -EFAULT;
        }
#endif
#endif

        stAiInfo.dev = dev;
        stAiInfo.total_size = total_size;
        stAiInfo.tmpBuf = tmpBuf;
        stAiInfo.tmpBufSize = sizeof(tmpBuf);
        stAiInfo.channels = sPcmCfg.n16Channels;
        stAiInfo.channelSize = sizeof(channelSize);
        stAiInfo.interleaved = sPcmCfg.nInterleaved;
        stAiInfo.nSpecialDumpChannels = sPcmCfg.nSpecialDumpChannels;

        if ( use_thread != 0 )
        {
            ai_thread_finish_flag = 0;

            ai_thread = kthread_run(_AiThread, &stAiInfo, "ai_thread" );

#if TEST_DPGA_GAIN_FADING
#if TEST_FADING_AI

            CamOsMsSleep(1000);

            if ((MHAL_AUDIO_SetGainIn(dev, -20, 0) != 0) || (MHAL_AUDIO_SetGainIn(dev, -20, 1) != 0))
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL, "TEST_DPGA_GAIN_FADING - MHAL_AUDIO_SetGainIn -20 fail !!!\n");
                return -EFAULT;
            }
#endif
#endif

            if (IS_ERR(ai_thread))
            {
                kthread_stop(ai_thread);
                AUD_UT_PRINTF(ERROR_UT_LEVEL, "ai_thread fail !\n");
            }
            else
            {
                while ( ai_thread_finish_flag == 0 )
                {
                    CamOsMsSleep(10);
#if TEST_ADC_GAIN
                    {
                        static int nAdcGain = 0; // 0~21

                        if ((MHAL_AUDIO_SetAdcGain(dev, nAdcGain, 0) != 0) || (MHAL_AUDIO_SetAdcGain(dev, nAdcGain, 1) != 0))
                        {
                            AUD_UT_PRINTF(ERROR_UT_LEVEL, "TEST_ADC_GAIN - MHAL_AUDIO_SetAdcGain = %d fail !!!\n",nAdcGain);
                            return -EFAULT;
                        }

                        nAdcGain++;

                        if ( nAdcGain > 21 )
                        {
                            nAdcGain = 0;
                        }

                        CamOsMsSleep(500);
                    }

#endif
                }

                kthread_stop(ai_thread);
                AUD_UT_PRINTF(TRACE_UT_LEVEL,"Ai Thread Finsh !\n");
            }
        }
        else
        {
            _AiRun( &stAiInfo );
        }

fail:

        // File Close
        if ( sPcmCfg.nSpecialDumpChannels != 0 )
        {
            for(i=0; i<sPcmCfg.nSpecialDumpChannels; i++)
            {
                filp_close(*(fw+i), NULL);
            }
            kfree(fw);
        }
        else
        {
            if(sPcmCfg.nInterleaved)
            {
                if(sPcmCfg.n16Channels == 4)
                {
                    for(i=0; i<sPcmCfg.n16Channels/2; i++)
                    {
                        filp_close(*(fw+i), NULL);
                    }
                    kfree(fw);
                }
                else
                {
                    filp_close((*fw), NULL);
                    kfree(fw);
                }
            }
            else
            {
                for(i=0; i<sPcmCfg.n16Channels; i++)
                {
                    filp_close(*(fw+i), NULL);
                }
                kfree(fw);
            }
        }

        //
        ret = MHAL_AUDIO_StopPcmIn(dev);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_StopPcmIn error=%d!!!\n",ret);
            //return -EFAULT;
        }
        ret = MHAL_AUDIO_ClosePcmIn(dev);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_ClosePcmIn error=%d!!!\n",ret);
            return -EFAULT;
        }

        //
        AUD_UT_PRINTF(LOG_UT_LEVEL,"Ai PCM Test Finish !\n");

        break;
    }

    case AUDRV_SET_DPGA_GAIN:

        if (copy_from_user(&sGainCfg, (void __user *)arg,sizeof(sGainCfg))!=0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_SET_DPGA_GAIN arg error !!!\n");
            return -EFAULT;
        }

        if (MHAL_AUDIO_SetGainIn(dev, sGainCfg.s16Gain, sGainCfg.s8Ch) != 0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_SetGainIn fail !!!\n");
            return -EFAULT;
        }

        break;

    case AUDRV_SET_ADC_GAIN:

        if (copy_from_user(&sGainCfg, (void __user *)arg,sizeof(sGainCfg))!=0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_SET_ADC_GAIN arg error !!!\n");
            return -EFAULT;
        }

        if (MHAL_AUDIO_SetAdcGain(dev, sGainCfg.s16Gain, sGainCfg.s8Ch) != 0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_SetAdcGain fail !!!\n");
            return -EFAULT;
        }

        //AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_SET_ADC_GAIN, dev = %d, Gain = %d !\n",dev,nGain);
        break;

    case AUDRV_SET_DMIC_GAIN:

        if (copy_from_user(&sGainCfg, (void __user *)arg,sizeof(sGainCfg))!=0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_SET_DMIC_GAIN arg error !!!\n");
            return -EFAULT;
        }

        if (MHAL_AUDIO_SetDmicGain(dev, sGainCfg.s16Gain, sGainCfg.s8Ch) != 0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_SetDmicGain fail !!!\n");
            return -EFAULT;
        }

        //AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_SET_DMIC_GAIN, dev = %d, Gain = %d !\n",dev,nGain);
        break;

    case AUDRV_BENCH_AIO_START:

        AUD_UT_PRINTF(TRACE_UT_LEVEL,"ioctl AUDRV_BENCH_AIO_START - CAPTURE\n");

        if (copy_from_user(&sPcmCfg, (void __user *)arg,sizeof(sPcmCfg))!=0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH CONFIG - arg error!!!\n");
            return -EFAULT;
        }
        else
        {
            AUD_UT_PRINTF(TRACE_UT_LEVEL, "BENCH CONFIG - arg get!!!\n");
        }

        if(((1 != sPcmCfg.n16Channels) && (0 != sPcmCfg.n16Channels%2)) || (8 < sPcmCfg.n16Channels))
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "Channels set error!!. \n");
            return -1;
        }

        //
        if(sPcmCfg.nRate==8000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_8K;
        else if(sPcmCfg.nRate==16000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_16K;
        else if(sPcmCfg.nRate==32000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_32K;
        else if(sPcmCfg.nRate==48000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_48K;
        else
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH CONFIG - sample rate %d not support!!!\n",sPcmCfg.nRate);
            return -EFAULT;
        }

        if(sPcmCfg.nBitWidth==16)
            tPcm.eWidth = E_MHAL_AUDIO_BITWIDTH_16;
        else if(sPcmCfg.nBitWidth==32)
            tPcm.eWidth = E_MHAL_AUDIO_BITWIDTH_32;
        else
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH CONFIG - bitwidth %d not support!!!\n",sPcmCfg.nBitWidth);
            return -EFAULT;
        }
        tPcm.u16Channels = sPcmCfg.n16Channels;
        tPcm.bInterleaved = sPcmCfg.nInterleaved;
        tPcm.pu8DmaArea = buf.area;
        tPcm.phyDmaAddr = buf.addr-MIU_OFFSET;
        tPcm.u32BufferSize = buf.bytes;
        tPcm.u32PeriodSize = sPcmCfg.n32PeriodSize;//7680;//1024*2*2*6;
        tPcm.u32StartThres = sPcmCfg.n32StartThres;//buf.bytes+1;//buf.bytes/2;

        //
        total_size = sPcmCfg.nTimeMs*(sPcmCfg.nRate/1000)*sPcmCfg.n16Channels*(sPcmCfg.nBitWidth/8);

        AUD_UT_PRINTF(TRACE_UT_LEVEL,"BENCH CONFIG - AI total_size %d!!!\n",total_size);

        ret = MHAL_AUDIO_ConfigPcmIn(dev, &tPcm);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH CONFIG - MHAL_AUDIO_ConfigPcmIn error=%d!!!\n",ret);
            return -EFAULT;
        }
        ret = MHAL_AUDIO_OpenPcmIn(dev);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH CONFIG - MHAL_AUDIO_OpenPcmIn error=%d!!!\n",ret);
            goto fail;
        }

        ret = MHAL_AUDIO_StartPcmIn(dev);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH START - MHAL_AUDIO_StartPcmIn fail !!! ret = %d\n",ret);
            return -EFAULT;
        }
        else
        {
            AUD_UT_PRINTF(TRACE_UT_LEVEL,"BENCH START - AI DMA Start !\n");
        }

        break;

    case AUDRV_BENCH_AIO_STOP:
    {
        //
        ret = MHAL_AUDIO_StopPcmIn(dev);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH AI - MHAL_AUDIO_StopPcmIn error=%d!!!\n",ret);
            return -EFAULT;
        }
        ret = MHAL_AUDIO_ClosePcmIn(dev);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH AI - MHAL_AUDIO_ClosePcmIn error=%d!!!\n",ret);
            return -EFAULT;
        }

        //
        AUD_UT_PRINTF(TRACE_UT_LEVEL,"BENCH Ai - Ai PCM Test Finish !\n");
        break;
    }

    case AUDRV_BENCH_READ:

        AUD_UT_PRINTF(TRACE_UT_LEVEL,"ioctl AUDRV_BENCH_READ\n");

        if (copy_from_user(&sBenchRead, (void __user *)arg,sizeof(sBenchRead))!=0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH READ - arg error!!!\n");
            return -EFAULT;
        }
        else
        {
            AUD_UT_PRINTF(TRACE_UT_LEVEL, "BENCH READ - arg get!!!\n");
        }

        if (MHAL_AUDIO_IsPcmInXrun(dev))
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH READ - AI Full ! XRUN !!!\n");

            ret = MHAL_AUDIO_StartPcmIn(dev);
            if(ret)
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH READ - MHAL_AUDIO_StartPcmIn fail !!! ret = %d\n",ret);
                return 0;
            }
            else
            {
                AUD_UT_PRINTF(TRACE_UT_LEVEL,"BENCH READ - AI DMA Start Re-Start !!!\n");
            }
        }

        ret = MHAL_AUDIO_ReadDataIn(dev, buf_bench.area, sBenchRead.nLen, TRUE);
        if (ret<0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH READ - MHAL_AUDIO_ReadDataIn fail !!!, ret = %d\n",ret);
            return -EFAULT;
        }
        else
        {
            if ( copy_to_user((char __user *)sBenchRead.aBufAddr, (char *)buf_bench.area, sBenchRead.nLen) )
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH READ - copy_to_user fail !!!\n");
                return -EFAULT;
            }
        }

        break;

    case AUDRV_DMA_SINEGEN:
    {
        if (copy_from_user(&tSineGenCfg, (void __user *)arg,sizeof(tSineGenCfg))!=0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "DMA_SINEGEN - arg error!!!\n");
            return -EFAULT;
        }
        else
        {

            AUD_UT_PRINTF(TRACE_UT_LEVEL, "DMA_SINEGEN - arg get!!!\n");
        }

        ret = MHAL_AUDIO_DmaSineGenIn(dev, tSineGenCfg);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH AI - MHAL_AUDIO_DmaSineGenIn error=%d!!!\n",ret);
        }

        break;
    }

    default:
        AUD_UT_PRINTF(ERROR_UT_LEVEL, "Unknown IOCTL Command 0x%08X !!!\n", cmd);
        return -ENOTTY;
    }
    return 0;
}

static long AudioPlayIoctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    struct AUD_PcmCfg_s sPcmCfg;
    struct AUD_GainCfg_s sGainCfg;
    MHAL_AUDIO_PcmCfg_t tPcm;
    MHAL_AUDIO_I2sCfg_t tI2sCfg;
    MHAL_AUDIO_SineGenCfg_t tSineGenCfg;
    struct pcm_data *pPcmData = (struct pcm_data *)filp->private_data;
    int dev = pPcmData->dev_id;
    int ret;
    int total_size = 0;
    u8 *pDataArray;
    int nArrSize;
    int nStartThres;
    _AO_Info_t stAoInfo;

    memset(&stAoInfo, 0, sizeof(stAoInfo));
    switch(cmd)
    {
    case AUDRV_PCM_TEST:
    {
        if (copy_from_user(&sPcmCfg, (void __user *)arg,sizeof(sPcmCfg))!=0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_PCM_TEST arg error!!!\n");
            return -EFAULT;
        }
        else
        {

            AUD_UT_PRINTF(TRACE_UT_LEVEL, "AUDRV_PCM_TEST arg get!!!\n");
        }

        if (sPcmCfg.aoUseFile)
        {
            stAoInfo.play_wav = 1;
            strcpy(stAoInfo.fileName, sPcmCfg.file_name);
            ao_file = filp_open(sPcmCfg.file_name, O_RDWR , 0644);
            if (IS_ERR(ao_file))
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_PCM_IOCTL ao filp open %s err %d\n",sPcmCfg.file_name, PTR_ERR(ao_file));
                return -EFAULT;
            }

            fs = get_fs();
            set_fs(KERNEL_DS);
            ret = vfs_read(ao_file, (char *)&stWavHeaderInput, sizeof(WaveFileHeader_t), &ao_file->f_pos);
            if (ret < 0)
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_PCM_IOCTL ao filp_read err\n");
                return -1;
            }
            sPcmCfg.n16Channels = stWavHeaderInput.wave.wChannels;
            sPcmCfg.nRate = stWavHeaderInput.wave.dwSamplesPerSec;
        }

        if(sPcmCfg.nRate==8000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_8K;
        else if(sPcmCfg.nRate==11000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_11K;
        else if(sPcmCfg.nRate==12000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_12K;
        else if(sPcmCfg.nRate==16000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_16K;
        else if(sPcmCfg.nRate==22000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_22K;
        else if(sPcmCfg.nRate==24000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_24K;
        else if(sPcmCfg.nRate==32000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_32K;
        else if(sPcmCfg.nRate==44000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_44K;
        else if(sPcmCfg.nRate==48000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_48K;
        else
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_PCM_IOCTL sample rate %d not support!!!\n",sPcmCfg.nRate);
            return -EFAULT;
        }

        if(sPcmCfg.nBitWidth==16)
            tPcm.eWidth = E_MHAL_AUDIO_BITWIDTH_16;
        else if(sPcmCfg.nBitWidth==32)
            tPcm.eWidth = E_MHAL_AUDIO_BITWIDTH_32;
        else
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_PCM_IOCTL bitwidth %d not support!!!\n",sPcmCfg.nBitWidth);
            return -EFAULT;
        }

        if(sPcmCfg.n16Channels==1)
        {
            pDataArray = tone_48k_mono;
            nArrSize = sizeof(tone_48k_mono);
        }
        else if(sPcmCfg.n16Channels==2)
        {
            if(sPcmCfg.nInterleaved)
            {
                pDataArray = tone_48k;
                nArrSize = sizeof(tone_48k);
            }
            else
            {
                pDataArray = tone_48k_noninterleave;
                nArrSize = sizeof(tone_48k_noninterleave);
            }
        }
        else
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_PCM_IOCTL channel %d not support!!!\n",sPcmCfg.n16Channels);
            return -EFAULT;
        }


        tPcm.u16Channels = sPcmCfg.n16Channels;
        tPcm.bInterleaved = sPcmCfg.nInterleaved;
        tPcm.pu8DmaArea = buf_AO.area;
        tPcm.phyDmaAddr = buf_AO.addr-MIU_OFFSET;
        tPcm.u32BufferSize = buf_AO.bytes;
        tPcm.u32PeriodSize = sPcmCfg.n32PeriodSize;//1024*2*2*6;
        tPcm.u32StartThres = sPcmCfg.n32StartThres;//buf.bytes+1;//buf.bytes/2;

        if(sPcmCfg.nI2sConfig)
        {
            if(sPcmCfg.sI2s.nTdmMode==1)
            {
                if(sPcmCfg.sI2s.nMsMode==0)
                {
                    tI2sCfg.eMode = E_MHAL_AUDIO_MODE_TDM_MASTER;
                }
                else
                {
                    tI2sCfg.eMode = E_MHAL_AUDIO_MODE_TDM_SLAVE;
                }
            }
            else if(sPcmCfg.sI2s.nTdmMode==0)
            {
                if(sPcmCfg.sI2s.nMsMode==0)
                {
                    tI2sCfg.eMode = E_MHAL_AUDIO_MODE_I2S_MASTER;
                }
                else
                {
                    tI2sCfg.eMode = E_MHAL_AUDIO_MODE_I2S_SLAVE;
                }
            }
            else
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_PCM_IOCTL I2S mode not support!!!\n");
                return -EFAULT;
            }

            tI2sCfg.eWidth = (sPcmCfg.sI2s.nBitWidth?E_MHAL_AUDIO_BITWIDTH_32:E_MHAL_AUDIO_BITWIDTH_16);

            tI2sCfg.eFmt = (sPcmCfg.sI2s.nFmt?E_MHAL_AUDIO_I2S_FMT_LEFT_JUSTIFY:E_MHAL_AUDIO_I2S_FMT_I2S);

            tI2sCfg.u16Channels = sPcmCfg.sI2s.u16Channels;

            tI2sCfg.eMck = sPcmCfg.sI2s.eMck;

            tI2sCfg.e4WireMode = sPcmCfg.sI2s.e4WireMode;

            tI2sCfg.eRate = tPcm.eRate;

            ret=MHAL_AUDIO_ConfigI2sOut(dev, &tI2sCfg);
            if(ret)
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL,"MHAL_AUDIO_ConfigI2sOut error=%d!!!\n",ret);
                return -EFAULT;
            }
        }
        total_size = sPcmCfg.nTimeMs*(sPcmCfg.nRate/1000)*sPcmCfg.n16Channels*(sPcmCfg.nBitWidth/8);

        AUD_UT_PRINTF(LOG_UT_LEVEL, "AO total_size %d!!!\n",total_size);

        if(sPcmCfg.n16Channels==1)
        {
            nStartThres = (buf_AO.bytes/2) - (sPcmCfg.n32PeriodSize*4);
        }
        else
        {
            nStartThres = (buf_AO.bytes/1) - (sPcmCfg.n32PeriodSize*4);
        }

        AUD_UT_PRINTF(LOG_UT_LEVEL, "AO threshold size %d\n",nStartThres);

        ret = MHAL_AUDIO_ConfigPcmOut(dev, &tPcm);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_ConfigPcmOut error=%d!!!\n",ret);
            return -EFAULT;
        }

        ret = MHAL_AUDIO_OpenPcmOut(dev);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_OpenPcmOut error=%d!!!\n",ret);
            goto fail;
        }

#if TEST_DPGA_GAIN_FADING
#if TEST_FADING_AO
        if ((MHAL_AUDIO_SetGainOut(dev, 0, 0, E_MHAL_AUDIO_GAIN_FADING_7) != 0) || (MHAL_AUDIO_SetGainOut(dev, 0, 1, E_MHAL_AUDIO_GAIN_FADING_7) != 0))
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "TEST_DPGA_GAIN_FADING - MHAL_AUDIO_SetGainOut fail !!!\n");
            return -EFAULT;
        }
#endif
#endif

        stAoInfo.dev = dev;
        stAoInfo.total_size = total_size;
        stAoInfo.pDataArray = pDataArray;
        stAoInfo.nArrSize = nArrSize;
        stAoInfo.nStartThres = nStartThres;

        if ( use_thread != 0 )
        {
            ao_thread_finish_flag = 0;

            ao_thread = kthread_run(_AoThread, &stAoInfo, "ao_thread" );

#if TEST_DPGA_GAIN_FADING
#if TEST_FADING_AO

            CamOsMsSleep(1000);

            if ((MHAL_AUDIO_SetGainOut(dev, -20, 0, E_MHAL_AUDIO_GAIN_FADING_7) != 0) || (MHAL_AUDIO_SetGainOut(dev, -20, 1, E_MHAL_AUDIO_GAIN_FADING_7) != 0))
            {
                AUD_UT_PRINTF(ERROR_UT_LEVEL, "TEST_DPGA_GAIN_FADING - MHAL_AUDIO_SetGainOut -20 fail !!!\n");
                return -EFAULT;
            }
#endif
#endif

            if (IS_ERR(ao_thread))
            {
                kthread_stop(ao_thread);
                AUD_UT_PRINTF(ERROR_UT_LEVEL, "ao_thread fail !\n");
            }
            else
            {
                while ( ao_thread_finish_flag == 0 )
                {
                    CamOsMsSleep(10);
                }

                kthread_stop(ao_thread);
            }
        }
        else
        {
            _AoRun( &stAoInfo );
        }

        //

fail:

#if TEST_AO_HOT_STOP
        //
#else
        ret = MHAL_AUDIO_StopPcmOut(dev);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_StopPcmOut error=%d!!!\n",ret);
            //return -EFAULT;
        }
#endif

        ret = MHAL_AUDIO_ClosePcmOut(dev);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_ClosePcmOut error=%d!!!\n",ret);
            return -EFAULT;
        }

        //
        AUD_UT_PRINTF(LOG_UT_LEVEL, "Ao PCM Test Finish !\n");

        if (sPcmCfg.aoUseFile)
        {
            filp_close(ao_file, NULL);
        }

        break;
    }

    case AUDRV_SET_DPGA_GAIN:

        if (copy_from_user(&sGainCfg, (void __user *)arg,sizeof(sGainCfg))!=0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "AUDRV_SET_DPGA_GAIN arg error !!!\n");
            return -EFAULT;
        }

        if (MHAL_AUDIO_SetGainOut(dev, sGainCfg.s16Gain, sGainCfg.s8Ch, E_MHAL_AUDIO_GAIN_FADING_7) != 0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "MHAL_AUDIO_SetGainOut fail !!!\n");
            return -EFAULT;
        }

        break;

    case AUDRV_BENCH_AIO_START:
    {
        AUD_UT_PRINTF(TRACE_UT_LEVEL,"ioctl AUDRV_BENCH_AIO_START - PLAYBACK\n");

        if (copy_from_user(&sPcmCfg, (void __user *)arg,sizeof(sPcmCfg))!=0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH AO - arg error!!!\n");
            return -EFAULT;
        }
        else
        {

            AUD_UT_PRINTF(TRACE_UT_LEVEL, "BENCH AO - arg get!!!\n");
        }

        if(sPcmCfg.nRate==8000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_8K;
        else if(sPcmCfg.nRate==16000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_16K;
        else if(sPcmCfg.nRate==32000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_32K;
        else if(sPcmCfg.nRate==48000)
            tPcm.eRate = E_MHAL_AUDIO_RATE_48K;
        else
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH AO - sample rate %d not support!!!\n",sPcmCfg.nRate);
            return -EFAULT;
        }

        if(sPcmCfg.nBitWidth==16)
            tPcm.eWidth = E_MHAL_AUDIO_BITWIDTH_16;
        else if(sPcmCfg.nBitWidth==32)
            tPcm.eWidth = E_MHAL_AUDIO_BITWIDTH_32;
        else
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH AO - bitwidth %d not support!!!\n",sPcmCfg.nBitWidth);
            return -EFAULT;
        }

        if(sPcmCfg.n16Channels==1)
        {
            pDataArray = tone_48k_mono;
            nArrSize = sizeof(tone_48k_mono);
        }
        else if(sPcmCfg.n16Channels==2)
        {
            if(sPcmCfg.nInterleaved)
            {
                pDataArray = tone_48k;
                nArrSize = sizeof(tone_48k);
            }
            else
            {
                pDataArray = tone_48k_noninterleave;
                nArrSize = sizeof(tone_48k_noninterleave);
            }
        }
        else
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH AO - channel %d not support!!!\n",sPcmCfg.n16Channels);
            return -EFAULT;
        }

        tPcm.u16Channels = sPcmCfg.n16Channels;
        tPcm.bInterleaved = sPcmCfg.nInterleaved;
        tPcm.pu8DmaArea = buf_AO.area;
        tPcm.phyDmaAddr = buf_AO.addr-MIU_OFFSET;
        tPcm.u32BufferSize = buf_AO.bytes;
        tPcm.u32PeriodSize = sPcmCfg.n32PeriodSize;//1024*2*2*6;
        tPcm.u32StartThres = sPcmCfg.n32StartThres;//buf.bytes+1;//buf.bytes/2;

        AUD_UT_PRINTF(TRACE_UT_LEVEL,"BENCH AO - AO total_size %d!!!\n",total_size);

        if(sPcmCfg.n16Channels==1)
        {
            nStartThres = (buf_AO.bytes/2) - (sPcmCfg.n32PeriodSize*4);
        }
        else
        {
            nStartThres = (buf_AO.bytes/1) - (sPcmCfg.n32PeriodSize*4);
        }

        ret = MHAL_AUDIO_ConfigPcmOut(dev, &tPcm);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH AO - MHAL_AUDIO_ConfigPcmOut error=%d!!!\n",ret);
            return -EFAULT;
        }

        ret = MHAL_AUDIO_OpenPcmOut(dev);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH AO - MHAL_AUDIO_OpenPcmOut error=%d!!!\n",ret);
        }
        else
        {
            //MHAL_AUDIO_StartPcmOut(dev);
            // Use Sin Gen
        }

        break;
    }

    case AUDRV_BENCH_AIO_STOP:
    {
        AUD_UT_PRINTF(TRACE_UT_LEVEL,"ioctl AUDRV_BENCH_AIO_STOP - PLAYBACK\n");

        //ret = MHAL_AUDIO_StopPcmOut(dev);
        //if(ret)
        //{
        //    AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH AO - MHAL_AUDIO_StopPcmOut error=%d!!!\n",ret);
        //    return -EFAULT;
        //}

        ret = MHAL_AUDIO_ClosePcmOut(dev);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH AO - MHAL_AUDIO_ClosePcmOut error=%d!!!\n",ret);
            return -EFAULT;
        }

        //
        //AUD_UT_PRINTF(LOG_UT_LEVEL, "BENCH AO - Ao PCM Test Finish !\n");

        break;
    }

    case AUDRV_DMA_SINEGEN:
    {
        if (copy_from_user(&tSineGenCfg, (void __user *)arg,sizeof(tSineGenCfg))!=0)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "DMA_SINEGEN - arg error!!!\n");
            return -EFAULT;
        }
        else
        {

            AUD_UT_PRINTF(TRACE_UT_LEVEL, "DMA_SINEGEN - arg get!!!\n");
        }

        ret = MHAL_AUDIO_DmaSineGenOut(dev, tSineGenCfg);
        if(ret)
        {
            AUD_UT_PRINTF(ERROR_UT_LEVEL, "BENCH AO - MHAL_AUDIO_DmaSineGenOut error=%d!!!\n",ret);
        }

        break;
    }

    default:
        AUD_UT_PRINTF(ERROR_UT_LEVEL,"Unknown IOCTL Command 0x%08X\n", cmd);
        return -ENOTTY;
    }
    return 0;
}

static int AudioOpen(struct inode *inode, struct file *filp)
{
    char name[16];
    int size = 128*1024; //max=65535;
    int card = 0;
    int benchBufIdx = 0;
    int ret = 0;
    struct pcm_data *pPcmData;

    AUD_UT_PRINTF(TRACE_UT_LEVEL, "%s\n", __FUNCTION__);

    //
    pPcmData = kzalloc(sizeof(struct pcm_data), GFP_KERNEL);
    if (pPcmData == NULL)
    {
        ret =  -ENOMEM;
        goto out;
    }

    getDevAttr(iminor(inode),&pPcmData->playback,&pPcmData->dev_id);
    filp->private_data = pPcmData;

    if(pPcmData->playback == FALSE)
    {
        //AI buffer allocate
        snprintf(name, 16, "pcmC%d", card);

        buf.area = alloc_dmem(name, PAGE_ALIGN(size),&buf.addr);

        if (!buf.area)
            return -ENOMEM;
        buf.bytes = PAGE_ALIGN(size);

        AUD_UT_PRINTF(TRACE_UT_LEVEL, "%s dma buffer size 0x%x\n",name, buf.bytes);
        AUD_UT_PRINTF(TRACE_UT_LEVEL, "physical dma address 0x%08x\n", buf.addr-MIU_OFFSET);
        AUD_UT_PRINTF(TRACE_UT_LEVEL, "virtual dma address 0x%08x\n", (unsigned int)buf.area);

        // For Bench
        snprintf(name, 16, "AudioBench%d", benchBufIdx);

        buf_bench.area = alloc_dmem(name, PAGE_ALIGN(size),&buf_bench.addr);

        if (!buf_bench.area)
            return -ENOMEM;
        buf_bench.bytes = PAGE_ALIGN(size);
    }
    else
    {
        //AO buffer allocate
        snprintf(name, 16, "pcmC%d", card+1);

        buf_AO.area = alloc_dmem(name, PAGE_ALIGN(size),&buf_AO.addr);

        if (!buf_AO.area)
            return -ENOMEM;
        buf_AO.bytes = PAGE_ALIGN(size);

        AUD_UT_PRINTF(TRACE_UT_LEVEL, "%s dma buffer size 0x%x\n",name, buf_AO.bytes);
        AUD_UT_PRINTF(TRACE_UT_LEVEL, "physical dma address 0x%08x\n", buf_AO.addr-MIU_OFFSET);
        AUD_UT_PRINTF(TRACE_UT_LEVEL, "virtual dma address 0x%08x\n", (unsigned int)buf_AO.area);
    }

out:
    return ret;
}

static int AudioRelease(struct inode *inode, struct file *filp)
{
    char name[16];
    int card = 0;
    int benchBufIdx = 0;
    struct pcm_data *pPcmData;

    AUD_UT_PRINTF(TRACE_UT_LEVEL, "%s\n", __FUNCTION__);

    pPcmData = filp->private_data;

    if(pPcmData->playback == FALSE)
    {
        snprintf(name, 16, "pcmC%d", card);
        free_dmem(name, buf.bytes, buf.area, buf.addr);

        snprintf(name, 16, "AudioBench%d", benchBufIdx);
        free_dmem(name, buf_bench.bytes, buf_bench.area, buf_bench.addr);
    }
    else
    {
        snprintf(name, 16, "pcmC%d", card+1);
        free_dmem(name, buf_AO.bytes, buf_AO.area, buf_AO.addr);
    }

    //
    if(filp->private_data)
        kfree(filp->private_data);

    filp->private_data = NULL;

    return 0;
}

static long AudioIoctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    int err= 0;
    struct pcm_data *pPcmData = (struct pcm_data *)filp->private_data;
    AUD_UT_PRINTF(TRACE_UT_LEVEL, "%s 0x%x!\n",__FUNCTION__,cmd);
    // wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
    if (_IOC_TYPE(cmd) != AUDIO_IOCTL_MAGIC) return -ENOTTY;
    if (_IOC_NR(cmd) > IOCTL_AUDIO_MAXNR) return -ENOTTY;

    if (_IOC_DIR(cmd) & _IOC_READ)
    {
        err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
    }
    else if (_IOC_DIR(cmd) & _IOC_WRITE)
    {
        err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
    }
    if (err)
    {
        return -EFAULT;
    }

    if(pPcmData->playback)
        err = AudioPlayIoctl(filp,cmd,arg);
    else
        err = AudioCapIoctl(filp,cmd,arg);

    //AUD_UT_PRINTF(ERROR_UT_LEVEL, "%s return err = %d!!!\n",__FUNCTION__,err);
    if(err)
        AUD_UT_PRINTF(ERROR_UT_LEVEL, "%s return err = %d!!!\n",__FUNCTION__,err);

    return err;
}


static struct cdev gsAudioCdev =
{
    .kobj = {.name= "audio", },
    .owner = THIS_MODULE,
};

static dev_t gAudioDev;
struct class *gpAudioClass = NULL;

static struct file_operations sAudioFops =
{
    .open = AudioOpen,
    .release = AudioRelease,
    .unlocked_ioctl = AudioIoctl
};
#if 0
static ssize_t play_time_show(struct device *dev, struct device_attribute *attr, char *buf)
{
    char *str = buf;
    char *end = buf + PAGE_SIZE;

    str += scnprintf(str, end - str, "%llu\n",g_nPlayStartTime);

    return (str - buf);
}

DEVICE_ATTR(play_time, 0444, play_time_show, NULL);

static ssize_t cap_time_show(struct device *dev, struct device_attribute *attr, char *buf)
{
    char *str = buf;
    char *end = buf + PAGE_SIZE;

    str += scnprintf(str, end - str, "%llu\n",g_nCapStartTime);

    return (str - buf);
}

DEVICE_ATTR(cap_time, 0444, cap_time_show, NULL);
#endif

static int DrvAudioModuleProbe(struct platform_device *pdev)
{
    AUD_UT_PRINTF(TRACE_UT_LEVEL, "%s\r\n", __FUNCTION__);

    MHAL_AUDIO_Init(NULL);

    return 0;
}

static int DrvAudioModuleRemove(struct platform_device *pdev)
{
    return 0;
}

static int DrvAudioModuleSuspend(struct platform_device *dev, pm_message_t state)
{
    int ret = 0;
    AUD_UT_PRINTF(TRACE_UT_LEVEL, "%s\r\n", __FUNCTION__);
    MHAL_AUDIO_DeInit();
    return ret;
}

static int DrvAudioModuleResume(struct platform_device *dev)
{
    int ret = 0;
    AUD_UT_PRINTF(TRACE_UT_LEVEL, "%s\r\n", __FUNCTION__);
    MHAL_AUDIO_Init(NULL);
    return ret;
}

static struct platform_driver stAudPlatformDriver =
{
    .probe      = DrvAudioModuleProbe,
    .remove     = DrvAudioModuleRemove,
    .suspend    = DrvAudioModuleSuspend,
    .resume     = DrvAudioModuleResume,
    .driver =
    {
        .name   = "ms-audio",
        .owner  = THIS_MODULE,
    },
};

static struct platform_device *pAudPlatformDev = NULL;
int DrvAudioModuleInit(void)
{
    int ret = 0;
    int i;
    struct device *dev;
    int major;
    int minor = 0;
    int card = 0;
    char str[16];

    AUD_UT_PRINTF(TRACE_UT_LEVEL, "%s\r\n", __FUNCTION__);

    ret = alloc_chrdev_region(&gAudioDev, 0, AUDIO_DEV, "audio");
    if (ret)
    {
        AUD_UT_PRINTF(ERROR_UT_LEVEL,"can't alloc chrdev\n");
        return ret;
    }

    cdev_init(&gsAudioCdev, &sAudioFops);
    if (0 != (ret= cdev_add(&gsAudioCdev, gAudioDev, AUDIO_DEV)))
    {
        AUD_UT_PRINTF(ERROR_UT_LEVEL, "%s:Unable add a character device\n", __FUNCTION__);
        unregister_chrdev_region(gAudioDev, 1);
        return ret;
    }

    gpAudioClass = CamClassCreate(THIS_MODULE, "audio");
    if(IS_ERR(gpAudioClass))
    {
        AUD_UT_PRINTF(ERROR_UT_LEVEL, "%s:Failed at class_create().Please exec [mknod] before operate the device\n", __FUNCTION__);
    }
    else
    {
        major = MAJOR(gAudioDev);
        /* create capture device */
        for(i=0; i<AUDIO_IN_DEV; i++)
        {
            sprintf(str, "aio_pcmC%iD%ic", card, i);
            dev = CamDeviceCreate(gpAudioClass, NULL, MKDEV(major,minor), NULL, str);
            if (IS_ERR(dev))
            {
                ret = PTR_ERR(dev);
                cdev_del(&gsAudioCdev);
                unregister_chrdev_region(gAudioDev, AUDIO_DEV);
            }
            minor++;
        }

        /* create playback device */
        for(i=0; i<AUDIO_OUT_DEV; i++)
        {
            sprintf(str, "aio_pcmC%iD%ip", card, i);
            dev = CamDeviceCreate(gpAudioClass, NULL, MKDEV(major,minor), NULL, str);
            if (IS_ERR(dev))
            {
                ret = PTR_ERR(dev);
                cdev_del(&gsAudioCdev);
                unregister_chrdev_region(gAudioDev, AUDIO_DEV);
            }
            minor++;
        }
    }

    {
        /* ret = device_create_file(dev, &dev_attr_play_time);
         if(ret)
             AUD_UT_PRINTF(ERROR_UT_LEVEL, "%s:add attibute failed\n", __FUNCTION__);

         ret = device_create_file(dev, &dev_attr_cap_time);
         if(ret)
             AUD_UT_PRINTF(ERROR_UT_LEVEL, "%s:add attibute failed\n", __FUNCTION__);*/
    }

    pAudPlatformDev = CamPlatformDeviceAlloc("ms-audio", -1);
    if (!pAudPlatformDev)
    {
        AUD_UT_PRINTF(ERROR_UT_LEVEL, "%s: platform_device_alloc ms-audio error\r\n", __FUNCTION__);
        return -ENOMEM;
    }

    ret = CamPlatformDeviceAdd(pAudPlatformDev);
    if (ret)
    {
        AUD_UT_PRINTF(ERROR_UT_LEVEL, "%s: platform_device_add infinity_snd_device error\r\n", __FUNCTION__);
        CamPlatformDevicePut(pAudPlatformDev);
    }

    ret = CamPlatformDriverRegister(&stAudPlatformDriver);
    if (ret)
    {
        AUD_UT_PRINTF(ERROR_UT_LEVEL, "%s: platform_driver_register voc_dma_driver error\r\n", __FUNCTION__);
        CamPlatformDeviceUnregister(pAudPlatformDev);
    }

    return ret;
}

void DrvAudioModuleExit(void)
{
    int i,major;

    AUD_UT_PRINTF(TRACE_UT_LEVEL, "%s\r\n", __FUNCTION__);
    major = MAJOR(gAudioDev);


    for(i=0; i<AUDIO_DEV; i++)
    {
        CamDeviceDestroy(gpAudioClass,MKDEV(major,i));
    }

    CamClassDestroy(gpAudioClass);

    cdev_del(&gsAudioCdev);

    unregister_chrdev_region(gAudioDev, AUDIO_DEV);

    CamPlatformDeviceUnregister(pAudPlatformDev);
    CamPlatformDriverUnregister(&stAudPlatformDriver);
}

module_init(DrvAudioModuleInit);
module_exit(DrvAudioModuleExit);

MODULE_LICENSE("PROPRIETARY");
// GPL
